var st=s=>{throw TypeError(s)};var V=(s,t,e)=>t.has(s)||st("Cannot "+e);var r=(s,t,e)=>(V(s,t,"read from private field"),e?e.call(s):t.get(s)),f=(s,t,e)=>t.has(s)?st("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(s):t.set(s,e),o=(s,t,e,i)=>(V(s,t,"write to private field"),i?i.call(s,e):t.set(s,e),e),l=(s,t,e)=>(V(s,t,"access private method"),e);import{S as ft,s as W,b as pt,i as rt,c as it,t as yt,f as bt,d as Rt,e as at,n as ut,a as gt,u as vt}from"./utils-Bx1BRerw.js";import{r as C}from"./index-Dl6G-zuu.js";import"./jsx-runtime-Du8NFWEI.js";var y,n,M,p,S,F,v,A,I,T,w,Q,E,x,a,D,z,H,N,K,q,G,J,ct,ot,mt=(ot=class extends ft{constructor(t,e){super();f(this,a);f(this,y);f(this,n);f(this,M);f(this,p);f(this,S);f(this,F);f(this,v);f(this,A);f(this,I);f(this,T);f(this,w);f(this,Q);f(this,E);f(this,x,new Set);this.options=e,o(this,y,t),o(this,v,null),this.bindMethods(),this.setOptions(e)}bindMethods(){this.refetch=this.refetch.bind(this)}onSubscribe(){this.listeners.size===1&&(r(this,n).addObserver(this),nt(r(this,n),this.options)?l(this,a,D).call(this):this.updateResult(),l(this,a,K).call(this))}onUnsubscribe(){this.hasListeners()||this.destroy()}shouldFetchOnReconnect(){return X(r(this,n),this.options,this.options.refetchOnReconnect)}shouldFetchOnWindowFocus(){return X(r(this,n),this.options,this.options.refetchOnWindowFocus)}destroy(){this.listeners=new Set,l(this,a,q).call(this),l(this,a,G).call(this),r(this,n).removeObserver(this)}setOptions(t,e){const i=this.options,b=r(this,n);if(this.options=r(this,y).defaultQueryOptions(t),typeof this.options.enabled<"u"&&typeof this.options.enabled!="boolean")throw new Error("Expected enabled to be a boolean");l(this,a,J).call(this),W(this.options,i)||r(this,y).getQueryCache().notify({type:"observerOptionsUpdated",query:r(this,n),observer:this});const u=this.hasListeners();u&&ht(r(this,n),b,this.options,i)&&l(this,a,D).call(this),this.updateResult(e),u&&(r(this,n)!==b||this.options.enabled!==i.enabled||this.options.staleTime!==i.staleTime)&&l(this,a,z).call(this);const h=l(this,a,H).call(this);u&&(r(this,n)!==b||this.options.enabled!==i.enabled||h!==r(this,E))&&l(this,a,N).call(this,h)}getOptimisticResult(t){const e=r(this,y).getQueryCache().build(r(this,y),t),i=this.createResult(e,t);return Ot(this,i)&&(o(this,p,i),o(this,F,this.options),o(this,S,r(this,n).state)),i}getCurrentResult(){return r(this,p)}trackResult(t){const e={};return Object.keys(t).forEach(i=>{Object.defineProperty(e,i,{configurable:!1,enumerable:!0,get:()=>(r(this,x).add(i),t[i])})}),e}getCurrentQuery(){return r(this,n)}refetch({...t}={}){return this.fetch({...t})}fetchOptimistic(t){const e=r(this,y).defaultQueryOptions(t),i=r(this,y).getQueryCache().build(r(this,y),e);return i.isFetchingOptimistic=!0,i.fetch().then(()=>this.createResult(i,e))}fetch(t){return l(this,a,D).call(this,{...t,cancelRefetch:t.cancelRefetch??!0}).then(()=>(this.updateResult(),r(this,p)))}createResult(t,e){var et;const i=r(this,n),b=this.options,u=r(this,p),h=r(this,S),d=r(this,F),U=t!==i?t.state:r(this,M),{state:c}=t;let{error:L,errorUpdatedAt:Z,fetchStatus:P,status:O}=c,$=!1,g;if(e._optimisticResults){const R=this.hasListeners(),_=!R&&nt(t,e),dt=R&&ht(t,i,e,b);(_||dt)&&(P=Rt(t.options.networkMode)?"fetching":"paused",c.dataUpdatedAt||(O="pending")),e._optimisticResults==="isRestoring"&&(P="idle")}if(e.select&&typeof c.data<"u")if(u&&c.data===(h==null?void 0:h.data)&&e.select===r(this,A))g=r(this,I);else try{o(this,A,e.select),g=e.select(c.data),g=at(u==null?void 0:u.data,g,e),o(this,I,g),o(this,v,null)}catch(R){o(this,v,R)}else g=c.data;if(typeof e.placeholderData<"u"&&typeof g>"u"&&O==="pending"){let R;if(u!=null&&u.isPlaceholderData&&e.placeholderData===(d==null?void 0:d.placeholderData))R=u.data;else if(R=typeof e.placeholderData=="function"?e.placeholderData((et=r(this,T))==null?void 0:et.state.data,r(this,T)):e.placeholderData,e.select&&typeof R<"u")try{R=e.select(R),o(this,v,null)}catch(_){o(this,v,_)}typeof R<"u"&&(O="success",g=at(u==null?void 0:u.data,R,e),$=!0)}r(this,v)&&(L=r(this,v),g=r(this,I),Z=Date.now(),O="error");const k=P==="fetching",B=O==="pending",j=O==="error",tt=B&&k;return{status:O,fetchStatus:P,isPending:B,isSuccess:O==="success",isError:j,isInitialLoading:tt,isLoading:tt,data:g,dataUpdatedAt:c.dataUpdatedAt,error:L,errorUpdatedAt:Z,failureCount:c.fetchFailureCount,failureReason:c.fetchFailureReason,errorUpdateCount:c.errorUpdateCount,isFetched:c.dataUpdateCount>0||c.errorUpdateCount>0,isFetchedAfterMount:c.dataUpdateCount>U.dataUpdateCount||c.errorUpdateCount>U.errorUpdateCount,isFetching:k,isRefetching:k&&!B,isLoadingError:j&&c.dataUpdatedAt===0,isPaused:P==="paused",isPlaceholderData:$,isRefetchError:j&&c.dataUpdatedAt!==0,isStale:Y(t,e),refetch:this.refetch}}updateResult(t){const e=r(this,p),i=this.createResult(r(this,n),this.options);if(o(this,S,r(this,n).state),o(this,F,this.options),r(this,S).data!==void 0&&o(this,T,r(this,n)),W(i,e))return;o(this,p,i);const b={},u=()=>{if(!e)return!0;const{notifyOnChangeProps:h}=this.options,d=typeof h=="function"?h():h;if(d==="all"||!d&&!r(this,x).size)return!0;const m=new Set(d??r(this,x));return this.options.throwOnError&&m.add("error"),Object.keys(r(this,p)).some(U=>{const c=U;return r(this,p)[c]!==e[c]&&m.has(c)})};(t==null?void 0:t.listeners)!==!1&&u()&&(b.listeners=!0),l(this,a,ct).call(this,{...b,...t})}onQueryUpdate(){this.updateResult(),this.hasListeners()&&l(this,a,K).call(this)}},y=new WeakMap,n=new WeakMap,M=new WeakMap,p=new WeakMap,S=new WeakMap,F=new WeakMap,v=new WeakMap,A=new WeakMap,I=new WeakMap,T=new WeakMap,w=new WeakMap,Q=new WeakMap,E=new WeakMap,x=new WeakMap,a=new WeakSet,D=function(t){l(this,a,J).call(this);let e=r(this,n).fetch(this.options,t);return t!=null&&t.throwOnError||(e=e.catch(pt)),e},z=function(){if(l(this,a,q).call(this),rt||r(this,p).isStale||!it(this.options.staleTime))return;const e=yt(r(this,p).dataUpdatedAt,this.options.staleTime)+1;o(this,w,setTimeout(()=>{r(this,p).isStale||this.updateResult()},e))},H=function(){return(typeof this.options.refetchInterval=="function"?this.options.refetchInterval(r(this,n)):this.options.refetchInterval)??!1},N=function(t){l(this,a,G).call(this),o(this,E,t),!(rt||this.options.enabled===!1||!it(r(this,E))||r(this,E)===0)&&o(this,Q,setInterval(()=>{(this.options.refetchIntervalInBackground||bt.isFocused())&&l(this,a,D).call(this)},r(this,E)))},K=function(){l(this,a,z).call(this),l(this,a,N).call(this,l(this,a,H).call(this))},q=function(){r(this,w)&&(clearTimeout(r(this,w)),o(this,w,void 0))},G=function(){r(this,Q)&&(clearInterval(r(this,Q)),o(this,Q,void 0))},J=function(){const t=r(this,y).getQueryCache().build(r(this,y),this.options);if(t===r(this,n))return;const e=r(this,n);o(this,n,t),o(this,M,t.state),this.hasListeners()&&(e==null||e.removeObserver(this),t.addObserver(this))},ct=function(t){ut.batch(()=>{t.listeners&&this.listeners.forEach(e=>{e(r(this,p))}),r(this,y).getQueryCache().notify({query:r(this,n),type:"observerResultsUpdated"})})},ot);function Ct(s,t){return t.enabled!==!1&&!s.state.dataUpdatedAt&&!(s.state.status==="error"&&t.retryOnMount===!1)}function nt(s,t){return Ct(s,t)||s.state.dataUpdatedAt>0&&X(s,t,t.refetchOnMount)}function X(s,t,e){if(t.enabled!==!1){const i=typeof e=="function"?e(s):e;return i==="always"||i!==!1&&Y(s,t)}return!1}function ht(s,t,e,i){return e.enabled!==!1&&(s!==t||i.enabled===!1)&&(!e.suspense||s.state.status!=="error")&&Y(s,e)}function Y(s,t){return s.isStaleByTime(t.staleTime)}function Ot(s,t){return!W(s.getCurrentResult(),t)}var lt=C.createContext(!1),Et=()=>C.useContext(lt);lt.Provider;function St(){let s=!1;return{clearReset:()=>{s=!1},reset:()=>{s=!0},isReset:()=>s}}var wt=C.createContext(St()),Qt=()=>C.useContext(wt),Ut=(s,t)=>{(s.suspense||s.throwOnError)&&(t.isReset()||(s.retryOnMount=!1))},Ft=s=>{C.useEffect(()=>{s.clearReset()},[s])},It=({result:s,errorResetBoundary:t,throwOnError:e,query:i})=>s.isError&&!t.isReset()&&!s.isFetching&&i&&gt(e,[s.error,i]),jt=(s,t)=>typeof t.state.data>"u",Tt=s=>{s.suspense&&typeof s.staleTime!="number"&&(s.staleTime=1e3)},_t=(s,t)=>s.isLoading&&s.isFetching&&!t,xt=(s,t)=>(s==null?void 0:s.suspense)&&t.isPending,Pt=(s,t,e)=>t.fetchOptimistic(s).catch(()=>{e.clearReset()});function Dt(s,t,e){const i=vt(),b=Et(),u=Qt(),h=i.defaultQueryOptions(s);h._optimisticResults=b?"isRestoring":"optimistic",Tt(h),Ut(h,u),Ft(u);const[d]=C.useState(()=>new t(i,h)),m=d.getOptimisticResult(h);if(C.useSyncExternalStore(C.useCallback(U=>{const c=b?()=>{}:d.subscribe(ut.batchCalls(U));return d.updateResult(),c},[d,b]),()=>d.getCurrentResult(),()=>d.getCurrentResult()),C.useEffect(()=>{d.setOptions(h,{listeners:!1})},[h,d]),xt(h,m))throw Pt(h,d,u);if(It({result:m,errorResetBoundary:u,throwOnError:h.throwOnError,query:i.getQueryCache().get(h.queryHash)}))throw m.error;return h.notifyOnChangeProps?m:d.trackResult(m)}function Vt(s,t){return Dt(s,mt)}export{mt as Q,Et as a,Qt as b,Ut as c,Ft as d,Tt as e,Pt as f,It as g,Dt as h,jt as i,xt as s,Vt as u,_t as w};
