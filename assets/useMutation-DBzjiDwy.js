var J=r=>{throw TypeError(r)};var F=(r,t,s)=>t.has(r)||J("Cannot "+s);var e=(r,t,s)=>(F(r,t,"read from private field"),s?s.call(r):t.get(r)),c=(r,t,s)=>t.has(r)?J("Cannot add the same private member more than once"):t instanceof WeakSet?t.add(r):t.set(r,s),n=(r,t,s,i)=>(F(r,t,"write to private field"),i?i.call(r,s):t.set(r,s),s),a=(r,t,s)=>(F(r,t,"access private method"),s);import{r as E}from"./index-BLuaxJdW.js";import{i as $,a as tt,n as A,c as et,b as st,S as it,s as rt,h as W,u as ot,d as nt}from"./utils-C1AHUSnA.js";var O,X,at=(X=class{constructor(){c(this,O)}destroy(){this.clearGcTimeout()}scheduleGc(){this.clearGcTimeout(),$(this.gcTime)&&n(this,O,setTimeout(()=>{this.optionalRemove()},this.gcTime))}updateGcTime(r){this.gcTime=Math.max(this.gcTime||0,r??(tt?1/0:5*60*1e3))}clearGcTimeout(){e(this,O)&&(clearTimeout(e(this,O)),n(this,O,void 0))}},O=new WeakMap,X),d,G,u,S,p,b,Y,pt=(Y=class extends at{constructor(t){super();c(this,p);c(this,d);c(this,G);c(this,u);c(this,S);this.mutationId=t.mutationId,n(this,G,t.defaultOptions),n(this,u,t.mutationCache),n(this,d,[]),this.state=t.state||_(),this.setOptions(t.options),this.scheduleGc()}setOptions(t){this.options={...e(this,G),...t},this.updateGcTime(this.options.gcTime)}get meta(){return this.options.meta}addObserver(t){e(this,d).includes(t)||(e(this,d).push(t),this.clearGcTimeout(),e(this,u).notify({type:"observerAdded",mutation:this,observer:t}))}removeObserver(t){n(this,d,e(this,d).filter(s=>s!==t)),this.scheduleGc(),e(this,u).notify({type:"observerRemoved",mutation:this,observer:t})}optionalRemove(){e(this,d).length||(this.state.status==="pending"?this.scheduleGc():e(this,u).remove(this))}continue(){var t;return((t=e(this,S))==null?void 0:t.continue())??this.execute(this.state.variables)}async execute(t){var l,w,m,C,R,T,f,M,D,I,U,j,q,L,N,Q,V,z,B,H;const s=()=>(n(this,S,et({fn:()=>this.options.mutationFn?this.options.mutationFn(t):Promise.reject(new Error("No mutationFn found")),onFail:(o,P)=>{a(this,p,b).call(this,{type:"failed",failureCount:o,error:P})},onPause:()=>{a(this,p,b).call(this,{type:"pause"})},onContinue:()=>{a(this,p,b).call(this,{type:"continue"})},retry:this.options.retry??0,retryDelay:this.options.retryDelay,networkMode:this.options.networkMode})),e(this,S).promise),i=this.state.status==="pending";try{if(!i){a(this,p,b).call(this,{type:"pending",variables:t}),await((w=(l=e(this,u).config).onMutate)==null?void 0:w.call(l,t,this));const P=await((C=(m=this.options).onMutate)==null?void 0:C.call(m,t));P!==this.state.context&&a(this,p,b).call(this,{type:"pending",context:P,variables:t})}const o=await s();return await((T=(R=e(this,u).config).onSuccess)==null?void 0:T.call(R,o,t,this.state.context,this)),await((M=(f=this.options).onSuccess)==null?void 0:M.call(f,o,t,this.state.context)),await((I=(D=e(this,u).config).onSettled)==null?void 0:I.call(D,o,null,this.state.variables,this.state.context,this)),await((j=(U=this.options).onSettled)==null?void 0:j.call(U,o,null,t,this.state.context)),a(this,p,b).call(this,{type:"success",data:o}),o}catch(o){try{throw await((L=(q=e(this,u).config).onError)==null?void 0:L.call(q,o,t,this.state.context,this)),await((Q=(N=this.options).onError)==null?void 0:Q.call(N,o,t,this.state.context)),await((z=(V=e(this,u).config).onSettled)==null?void 0:z.call(V,void 0,o,this.state.variables,this.state.context,this)),await((H=(B=this.options).onSettled)==null?void 0:H.call(B,void 0,o,t,this.state.context)),o}finally{a(this,p,b).call(this,{type:"error",error:o})}}}},d=new WeakMap,G=new WeakMap,u=new WeakMap,S=new WeakMap,p=new WeakSet,b=function(t){const s=i=>{switch(t.type){case"failed":return{...i,failureCount:t.failureCount,failureReason:t.error};case"pause":return{...i,isPaused:!0};case"continue":return{...i,isPaused:!1};case"pending":return{...i,context:t.context,data:void 0,failureCount:0,failureReason:null,error:null,isPaused:!st(this.options.networkMode),status:"pending",variables:t.variables,submittedAt:Date.now()};case"success":return{...i,data:t.data,failureCount:0,failureReason:null,error:null,status:"success",isPaused:!1};case"error":return{...i,data:void 0,error:t.error,failureCount:i.failureCount+1,failureReason:t.error,isPaused:!1,status:"error"}}};this.state=s(this.state),A.batch(()=>{e(this,d).forEach(i=>{i.onMutationUpdate(t)}),e(this,u).notify({mutation:this,type:"updated",action:t})})},Y);function _(){return{context:void 0,data:void 0,error:null,failureCount:0,failureReason:null,isPaused:!1,status:"idle",variables:void 0,submittedAt:0}}var x,g,h,y,v,k,K,Z,ut=(Z=class extends it{constructor(t,s){super();c(this,v);c(this,x);c(this,g);c(this,h);c(this,y);n(this,x,t),this.setOptions(s),this.bindMethods(),a(this,v,k).call(this)}bindMethods(){this.mutate=this.mutate.bind(this),this.reset=this.reset.bind(this)}setOptions(t){var i;const s=this.options;this.options=e(this,x).defaultMutationOptions(t),rt(this.options,s)||e(this,x).getMutationCache().notify({type:"observerOptionsUpdated",mutation:e(this,h),observer:this}),s!=null&&s.mutationKey&&this.options.mutationKey&&W(s.mutationKey)!==W(this.options.mutationKey)?this.reset():(i=e(this,h))==null||i.setOptions(this.options)}onUnsubscribe(){var t;this.hasListeners()||(t=e(this,h))==null||t.removeObserver(this)}onMutationUpdate(t){a(this,v,k).call(this),a(this,v,K).call(this,t)}getCurrentResult(){return e(this,g)}reset(){var t;(t=e(this,h))==null||t.removeObserver(this),n(this,h,void 0),a(this,v,k).call(this),a(this,v,K).call(this)}mutate(t,s){var i;return n(this,y,s),(i=e(this,h))==null||i.removeObserver(this),n(this,h,e(this,x).getMutationCache().build(e(this,x),this.options)),e(this,h).addObserver(this),e(this,h).execute(t)}},x=new WeakMap,g=new WeakMap,h=new WeakMap,y=new WeakMap,v=new WeakSet,k=function(){var s;const t=((s=e(this,h))==null?void 0:s.state)??_();n(this,g,{...t,isPending:t.status==="pending",isSuccess:t.status==="success",isError:t.status==="error",isIdle:t.status==="idle",mutate:this.mutate,reset:this.reset})},K=function(t){A.batch(()=>{var s,i,l,w,m,C,R,T;if(e(this,y)&&this.hasListeners()){const f=e(this,g).variables,M=e(this,g).context;(t==null?void 0:t.type)==="success"?((i=(s=e(this,y)).onSuccess)==null||i.call(s,t.data,f,M),(w=(l=e(this,y)).onSettled)==null||w.call(l,t.data,null,f,M)):(t==null?void 0:t.type)==="error"&&((C=(m=e(this,y)).onError)==null||C.call(m,t.error,f,M),(T=(R=e(this,y)).onSettled)==null||T.call(R,void 0,t.error,f,M))}this.listeners.forEach(f=>{f(e(this,g))})})},Z);function mt(r,t){const s=ot(),[i]=E.useState(()=>new ut(s,r));E.useEffect(()=>{i.setOptions(r)},[i,r]);const l=E.useSyncExternalStore(E.useCallback(m=>i.subscribe(A.batchCalls(m)),[i]),()=>i.getCurrentResult(),()=>i.getCurrentResult()),w=E.useCallback((m,C)=>{i.mutate(m,C).catch(ht)},[i]);if(l.error&&nt(i.options.throwOnError,[l.error]))throw l.error;return{...l,mutate:w,mutateAsync:l.mutate}}function ht(){}export{pt as M,at as R,mt as u};
