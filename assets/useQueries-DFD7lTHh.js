import{b7 as w,b8 as f,b9 as C,aA as m,aH as S,ba as x,bb as M,r as b,bc as q,bd as k,be as H,bf as P,bg as R,bh as g,bi as A,bj as B}from"./iframe-CS-qe6F5.js";function v(s,e){const r=new Set(e);return s.filter(t=>!r.has(t))}function L(s,e,r){const t=s.slice(0);return t[e]=r,t}var T=class extends w{#r;#e;#i;#n;#s;#t;#u;#o;#h=[];constructor(s,e,r){super(),this.#r=s,this.#n=r,this.#i=[],this.#s=[],this.#e=[],this.setQueries(e)}onSubscribe(){this.listeners.size===1&&this.#s.forEach(s=>{s.subscribe(e=>{this.#b(s,e)})})}onUnsubscribe(){this.listeners.size||this.destroy()}destroy(){this.listeners=new Set,this.#s.forEach(s=>{s.destroy()})}setQueries(s,e){this.#i=s,this.#n=e,f.batch(()=>{const r=this.#s,t=this.#l(this.#i);this.#h=t,t.forEach(n=>n.observer.setOptions(n.defaultedQueryOptions));const i=t.map(n=>n.observer),o=i.map(n=>n.getCurrentResult()),h=i.some((n,l)=>n!==r[l]);r.length===i.length&&!h||(this.#s=i,this.#e=o,this.hasListeners()&&(v(r,i).forEach(n=>{n.destroy()}),v(i,r).forEach(n=>{n.subscribe(l=>{this.#b(n,l)})}),this.#f()))})}getCurrentResult(){return this.#e}getQueries(){return this.#s.map(s=>s.getCurrentQuery())}getObservers(){return this.#s}getOptimisticResult(s,e){const r=this.#l(s),t=r.map(i=>i.observer.getOptimisticResult(i.defaultedQueryOptions));return[t,i=>this.#c(i??t,e),()=>this.#a(t,r)]}#a(s,e){return e.map((r,t)=>{const i=s[t];return r.defaultedQueryOptions.notifyOnChangeProps?i:r.observer.trackResult(i,o=>{e.forEach(h=>{h.observer.trackProp(o)})})})}#c(s,e){return e?((!this.#t||this.#e!==this.#o||e!==this.#u)&&(this.#u=e,this.#o=this.#e,this.#t=C(this.#t,e(s))),this.#t):s}#l(s){const e=new Map(this.#s.map(t=>[t.options.queryHash,t])),r=[];return s.forEach(t=>{const i=this.#r.defaultQueryOptions(t),o=e.get(i.queryHash);o?r.push({defaultedQueryOptions:i,observer:o}):r.push({defaultedQueryOptions:i,observer:new m(this.#r,i)})}),r}#b(s,e){const r=this.#s.indexOf(s);r!==-1&&(this.#e=L(this.#e,r,e),this.#f())}#f(){if(this.hasListeners()){const s=this.#t,e=this.#a(this.#e,this.#h),r=this.#c(e,this.#n?.combine);s!==r&&f.batch(()=>{this.listeners.forEach(t=>{t(this.#e)})})}}};function U({queries:s,...e},r){const t=S(),i=x(),o=M(),h=b.useMemo(()=>s.map(u=>{const c=t.defaultQueryOptions(u);return c._optimisticResults=i?"isRestoring":"optimistic",c}),[s,t,i]);h.forEach(u=>{q(u),k(u,o)}),H(o);const[n]=b.useState(()=>new T(t,h,e)),[l,E,Q]=n.getOptimisticResult(h,e.combine),d=!i&&e.subscribed!==!1;b.useSyncExternalStore(b.useCallback(u=>d?n.subscribe(f.batchCalls(u)):P,[n,d]),()=>n.getCurrentResult(),()=>n.getCurrentResult()),b.useEffect(()=>{n.setQueries(h,e)},[h,e,n]);const p=l.some((u,c)=>R(h[c],u))?l.flatMap((u,c)=>{const a=h[c];if(a){const O=new m(t,a);if(R(a,u))return g(a,O,o);A(u,i)&&g(a,O,o)}return[]}):[];if(p.length>0)throw Promise.all(p);const y=l.find((u,c)=>{const a=h[c];return a&&B({result:u,errorResetBoundary:o,throwOnError:a.throwOnError,query:t.getQueryCache().get(a.queryHash),suspense:a.suspense})});if(y?.error)throw y.error;return E(Q())}export{U as u};
