{"version":3,"file":"queryUtils-d25c846d.js","sources":["../../src/utils/functions/queryUtils.ts"],"sourcesContent":["import { cloneDeep, isEqual, isEqualWith, isMatch, isNil } from 'lodash-es'\nimport * as SynapseConstants from '../SynapseConstants'\nimport SynapseClient from '../../synapse-client'\nimport { LockedColumn } from '../../components/QueryContext/QueryContext'\nimport {\n  ColumnModel,\n  ColumnTypeEnum,\n  FacetColumnRequest,\n  FacetColumnResult,\n  JsonSubColumnModel,\n  Query,\n  QueryBundleRequest,\n  QueryResultBundle,\n  SelectColumn,\n  Table,\n} from '@sage-bionetworks/synapse-types'\n\nimport {\n  isColumnMultiValueFunctionQueryFilter,\n  isColumnSingleValueQueryFilter,\n} from '../types/IsType'\nimport { isDataset, isEntityView, isFileView } from './EntityTypeUtils'\nimport { UniqueFacetIdentifier } from '../types/UniqueFacetIdentifier'\n\ntype PartialStateObject = {\n  hasMoreData: boolean\n  data: QueryResultBundle\n}\n\n/**\n * Retrieve the index of a column using the column name\n * @param name the column name\n * @param result the QueryResultBundle containing the columns\n * @returns The index of the column, or -1 if the column doesn't exist in the result\n */\nexport const getFieldIndex = (\n  name: string,\n  result: QueryResultBundle | undefined,\n) => {\n  return (\n    result?.selectColumns?.findIndex(el => {\n      return el.name === name\n    }) ?? -1\n  )\n}\n\n/**\n * Retrieve the index of a column using the header column name found inthe query results.\n * Ignores case.\n * @param name the column name\n * @param result the QueryResultBundle containing the columns\n * @returns The index of the column, or -1 if the column doesn't exist in the result\n */\nexport const getHeaderIndex = (\n  name: string,\n  result: QueryResultBundle | undefined,\n) => {\n  const nameLowercase = name.toLowerCase()\n  return (\n    result?.queryResult?.queryResults.headers.findIndex(el => {\n      return el.name.toLowerCase() === nameLowercase\n    }) ?? -1\n  )\n}\n\n/**\n * Returns the indices of the selectColumns with the specified type\n * @param columnType\n * @param data\n */\nexport function getTypeIndices(\n  columnType: ColumnTypeEnum,\n  data?: QueryResultBundle,\n): number[] {\n  return (data?.selectColumns ?? []).reduce((prev: number[], curr, index) => {\n    if (curr.columnType === columnType) {\n      return [...prev, index]\n    }\n    return prev\n  }, [])\n}\n\n/**\n * Grab the next page of data, pulling in 25 more rows.\n *\n * @param {*} queryRequest Query request as specified by\n *                         https://rest-docs.synapse.org/rest/org/sagebionetworks/repo/model/table/Query.html\n */\nexport const getNextPageOfData = async (\n  queryRequest: QueryBundleRequest,\n  data: QueryResultBundle,\n  token?: string,\n) => {\n  return await SynapseClient.getQueryTableResults(queryRequest, token)\n    .then((newData: QueryResultBundle) => {\n      const oldData: QueryResultBundle = cloneDeep(data)!\n      // push on the new data retrieved from the API call\n      const hasMoreData =\n        newData.queryResult!.queryResults.rows.length ===\n          queryRequest.query.limit ?? SynapseConstants.DEFAULT_PAGE_SIZE\n      oldData.queryResult!.queryResults.rows.push(\n        ...newData.queryResult!.queryResults.rows,\n      )\n      const newState: PartialStateObject = {\n        hasMoreData,\n        data: oldData,\n      }\n      return newState\n    })\n    .catch(err => {\n      console.log('Failed to get data ', err)\n      return {} as PartialStateObject\n    })\n}\n\nexport const isFacetAvailable = (\n  facets?: FacetColumnResult[],\n  selectColumns?: SelectColumn[],\n): boolean => {\n  /**\n   *  Facets are available iff\n   *    * there is at least one facet AND\n   *    * each facet has a corresponding columnModel in the selectColumns AND\n   *    * each facets has a valid value other than the null/not set value\n   */\n  if (facets == null || selectColumns == null) {\n    return false\n  }\n\n  if (facets.length === 0 || selectColumns.length === 0) {\n    return false\n  }\n\n  const facetsWithValuesAndColumnModels = facets.filter(facet => {\n    return (\n      !isSingleNotSetValue(facet) &&\n      selectColumns.find(model => model.name === facet.columnName)\n    )\n  })\n\n  return facetsWithValuesAndColumnModels.length > 0\n}\n\nexport const isSingleNotSetValue = (facet: FacetColumnResult): boolean => {\n  return (\n    facet.facetType === 'enumeration' &&\n    facet.facetValues.length == 1 &&\n    facet.facetValues[0].value == SynapseConstants.VALUE_NOT_SET\n  )\n}\n\n// TODO Instead of removing the facet from the data, the facet renderers should just be aware of what to hide\nexport function removeLockedColumnFromFacetData(\n  data?: QueryResultBundle,\n  lockedColumn?: LockedColumn,\n): QueryResultBundle | undefined {\n  const lockedColumnName = lockedColumn?.columnName\n  if (lockedColumnName && data) {\n    // for details page, return data without the \"locked\" facet\n    const dataCopy: QueryResultBundle = cloneDeep(data)\n    const facets = dataCopy.facets?.filter(\n      item => item.columnName.toLowerCase() !== lockedColumnName.toLowerCase(),\n    )\n    dataCopy.facets = facets\n    return dataCopy\n  } else {\n    // for other pages, just return the data\n    return data\n  }\n}\n\n/**\n * Returns true iff the query has filters applied that can be reset.\n * This includes facet filters and additional filters that are not applied to a locked column.\n */\nexport function hasResettableFilters(\n  query: Query,\n  lockedColumn?: LockedColumn,\n): boolean {\n  const hasFacetFilters =\n    Array.isArray(query.selectedFacets) &&\n    query.selectedFacets.filter(\n      facet =>\n        facet.columnName.toLowerCase() !==\n        lockedColumn?.columnName?.toLowerCase(),\n    ).length > 0\n  const hasAdditionalFilters =\n    Array.isArray(query.additionalFilters) &&\n    query.additionalFilters.filter(queryFilter =>\n      isColumnSingleValueQueryFilter(queryFilter) ||\n      isColumnMultiValueFunctionQueryFilter(queryFilter)\n        ? queryFilter.columnName.toLowerCase() !==\n          lockedColumn?.columnName?.toLowerCase()\n        : true,\n    ).length > 0\n\n  return hasFacetFilters || hasAdditionalFilters\n}\n\nexport function canTableQueryBeAddedToDownloadList<T extends Table = Table>(\n  entity?: T,\n) {\n  return Boolean(\n    entity &&\n      ((isEntityView(entity) && isFileView(entity)) || isDataset(entity)),\n  )\n}\n\n/**\n * Returns true if the queries necessarily return the same result set, i.e. if they have identical parameters other than\n * limit, offset, sort.\n *\n * Note that this does not query the actual tables, so this only captures the semantic equivalence of the queries.\n */\nexport function queryRequestsHaveSameTotalResults(\n  request1: Query,\n  request2: Query,\n) {\n  const clone1 = cloneDeep(request1)\n  delete clone1.limit\n  delete clone1.offset\n  delete clone1.sort\n  const clone2 = cloneDeep(request2)\n  delete clone2.limit\n  delete clone2.offset\n  delete clone2.sort\n  return isEqualWith(clone1, clone2, (value1, value2) => {\n    if (isNil(value1) && isNil(value2)) {\n      // Consider all nil (e.g. undefined/null) values equal\n      return true\n    }\n    return isEqual(value1, value2)\n  })\n}\n\n/**\n * Remove null/empty values from the query parameters where an undefined value is equivalent.\n *\n * This will ensure a query object is as simple as possible for URL search parameters and also increases the\n * likelihood of a cache hit.\n * @param q\n */\nexport function removeEmptyQueryParams(q: Query) {\n  const query = cloneDeep(q)\n\n  if (query.limit == null) {\n    delete query.limit\n  }\n  if (query.offset == null) {\n    delete query.offset\n  }\n\n  if (query.sort == null || query.sort.length == 0) {\n    delete query.sort\n  }\n\n  if (query.selectedFacets == null || query.selectedFacets.length == 0) {\n    delete query.selectedFacets\n  }\n\n  if (query.additionalFilters == null || query.additionalFilters.length == 0) {\n    delete query.additionalFilters\n  }\n\n  return query\n}\n\n/**\n * Given a FacetColumnResult and a set of ColumnModels, return the ColumnModel that\n * matches the FacetColumnResult.\n * @param facet\n * @param columnModels\n */\nexport function getCorrespondingColumnForFacet(\n  facet: FacetColumnResult,\n  columnModels: ColumnModel[],\n): ColumnModel | JsonSubColumnModel | undefined {\n  let columnModel: ColumnModel | JsonSubColumnModel | undefined =\n    columnModels.find(model => model.name === facet.columnName)\n  if (facet.jsonPath && columnModel && columnModel.jsonSubColumns) {\n    columnModel = columnModel.jsonSubColumns.find(\n      cm => cm.jsonPath === facet.jsonPath,\n    )\n  }\n  return columnModel\n}\n\n/**\n * Given a set of FacetColumnRequests, return the FacetColumnRequest that matches the given UniqueFacetIdentifier.\n * @param facetDefinition\n * @param selectedFacets\n */\nexport function getCorrespondingSelectedFacet(\n  facetDefinition: UniqueFacetIdentifier,\n  selectedFacets?: FacetColumnRequest[],\n): FacetColumnRequest | undefined {\n  return selectedFacets?.find(selectedFacet =>\n    facetObjectMatchesDefinition(facetDefinition, selectedFacet),\n  )\n}\n\nexport function facetObjectMatchesDefinition(\n  facetDefinition:\n    | UniqueFacetIdentifier\n    | FacetColumnRequest\n    | FacetColumnResult,\n  facetObject: UniqueFacetIdentifier | FacetColumnRequest | FacetColumnResult,\n) {\n  return isMatch(\n    {\n      columnName: facetDefinition.columnName,\n      jsonPath: facetDefinition.jsonPath,\n    },\n    { columnName: facetObject.columnName, jsonPath: facetObject.jsonPath },\n  )\n}\n"],"names":["getFieldIndex","name","result","_a","el","getHeaderIndex","nameLowercase","getTypeIndices","columnType","data","prev","curr","index","isFacetAvailable","facets","selectColumns","facet","isSingleNotSetValue","model","SynapseConstants.VALUE_NOT_SET","removeLockedColumnFromFacetData","lockedColumn","lockedColumnName","dataCopy","cloneDeep","item","hasResettableFilters","query","hasFacetFilters","hasAdditionalFilters","queryFilter","isColumnSingleValueQueryFilter","isColumnMultiValueFunctionQueryFilter","canTableQueryBeAddedToDownloadList","entity","isEntityView","isFileView","isDataset","queryRequestsHaveSameTotalResults","request1","request2","clone1","clone2","isEqualWith","value1","value2","isNil","isEqual","removeEmptyQueryParams","q","getCorrespondingColumnForFacet","columnModels","columnModel","cm","getCorrespondingSelectedFacet","facetDefinition","selectedFacets","selectedFacet","facetObjectMatchesDefinition","facetObject","isMatch"],"mappings":"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"}