{"version":3,"file":"UserSearchBox.stories-dcb916de.js","sources":["../../../../node_modules/.pnpm/compute-scroll-into-view@1.0.20/node_modules/compute-scroll-into-view/dist/index.mjs","../../../../node_modules/.pnpm/downshift@6.1.12_react@18.2.0/node_modules/downshift/dist/downshift.esm.js","../../src/components/UserSearchBox/UserSearchBox.tsx"],"sourcesContent":["function t(t){return\"object\"==typeof t&&null!=t&&1===t.nodeType}function e(t,e){return(!e||\"hidden\"!==t)&&\"visible\"!==t&&\"clip\"!==t}function n(t,n){if(t.clientHeight<t.scrollHeight||t.clientWidth<t.scrollWidth){var r=getComputedStyle(t,null);return e(r.overflowY,n)||e(r.overflowX,n)||function(t){var e=function(t){if(!t.ownerDocument||!t.ownerDocument.defaultView)return null;try{return t.ownerDocument.defaultView.frameElement}catch(t){return null}}(t);return!!e&&(e.clientHeight<t.scrollHeight||e.clientWidth<t.scrollWidth)}(t)}return!1}function r(t,e,n,r,i,o,l,d){return o<t&&l>e||o>t&&l<e?0:o<=t&&d<=n||l>=e&&d>=n?o-t-r:l>e&&d<n||o<t&&d>n?l-e+i:0}var i=function(e,i){var o=window,l=i.scrollMode,d=i.block,f=i.inline,h=i.boundary,u=i.skipOverflowHiddenElements,s=\"function\"==typeof h?h:function(t){return t!==h};if(!t(e))throw new TypeError(\"Invalid target\");for(var a,c,g=document.scrollingElement||document.documentElement,p=[],m=e;t(m)&&s(m);){if((m=null==(c=(a=m).parentElement)?a.getRootNode().host||null:c)===g){p.push(m);break}null!=m&&m===document.body&&n(m)&&!n(document.documentElement)||null!=m&&n(m,u)&&p.push(m)}for(var w=o.visualViewport?o.visualViewport.width:innerWidth,v=o.visualViewport?o.visualViewport.height:innerHeight,W=window.scrollX||pageXOffset,H=window.scrollY||pageYOffset,b=e.getBoundingClientRect(),y=b.height,E=b.width,M=b.top,V=b.right,x=b.bottom,I=b.left,C=\"start\"===d||\"nearest\"===d?M:\"end\"===d?x:M+y/2,R=\"center\"===f?I+E/2:\"end\"===f?V:I,T=[],k=0;k<p.length;k++){var B=p[k],D=B.getBoundingClientRect(),O=D.height,X=D.width,Y=D.top,L=D.right,S=D.bottom,j=D.left;if(\"if-needed\"===l&&M>=0&&I>=0&&x<=v&&V<=w&&M>=Y&&x<=S&&I>=j&&V<=L)return T;var N=getComputedStyle(B),q=parseInt(N.borderLeftWidth,10),z=parseInt(N.borderTopWidth,10),A=parseInt(N.borderRightWidth,10),F=parseInt(N.borderBottomWidth,10),G=0,J=0,K=\"offsetWidth\"in B?B.offsetWidth-B.clientWidth-q-A:0,P=\"offsetHeight\"in B?B.offsetHeight-B.clientHeight-z-F:0,Q=\"offsetWidth\"in B?0===B.offsetWidth?0:X/B.offsetWidth:0,U=\"offsetHeight\"in B?0===B.offsetHeight?0:O/B.offsetHeight:0;if(g===B)G=\"start\"===d?C:\"end\"===d?C-v:\"nearest\"===d?r(H,H+v,v,z,F,H+C,H+C+y,y):C-v/2,J=\"start\"===f?R:\"center\"===f?R-w/2:\"end\"===f?R-w:r(W,W+w,w,q,A,W+R,W+R+E,E),G=Math.max(0,G+H),J=Math.max(0,J+W);else{G=\"start\"===d?C-Y-z:\"end\"===d?C-S+F+P:\"nearest\"===d?r(Y,S,O,z,F+P,C,C+y,y):C-(Y+O/2)+P/2,J=\"start\"===f?R-j-q:\"center\"===f?R-(j+X/2)+K/2:\"end\"===f?R-L+A+K:r(j,L,X,q,A+K,R,R+E,E);var Z=B.scrollLeft,$=B.scrollTop;C+=$-(G=Math.max(0,Math.min($+G/U,B.scrollHeight-O/U+P))),R+=Z-(J=Math.max(0,Math.min(Z+J/Q,B.scrollWidth-X/Q+K)))}T.push({el:B,top:G,left:J})}return T};export{i as default};\n//# sourceMappingURL=index.mjs.map\n","import PropTypes from 'prop-types';\nimport { Component, cloneElement, useRef, useEffect, useCallback, useLayoutEffect, useReducer, useMemo } from 'react';\nimport { isForwardRef } from 'react-is';\nimport computeScrollIntoView from 'compute-scroll-into-view';\nimport { __assign } from 'tslib';\n\nlet idCounter = 0;\n/**\n * Accepts a parameter and returns it if it's a function\n * or a noop function if it's not. This allows us to\n * accept a callback, but not worry about it if it's not\n * passed.\n * @param {Function} cb the callback\n * @return {Function} a function\n */\n\nfunction cbToCb(cb) {\n  return typeof cb === 'function' ? cb : noop;\n}\n\nfunction noop() {}\n/**\n * Scroll node into view if necessary\n * @param {HTMLElement} node the element that should scroll into view\n * @param {HTMLElement} menuNode the menu element of the component\n */\n\n\nfunction scrollIntoView(node, menuNode) {\n  if (!node) {\n    return;\n  }\n\n  const actions = computeScrollIntoView(node, {\n    boundary: menuNode,\n    block: 'nearest',\n    scrollMode: 'if-needed'\n  });\n  actions.forEach(_ref => {\n    let {\n      el,\n      top,\n      left\n    } = _ref;\n    el.scrollTop = top;\n    el.scrollLeft = left;\n  });\n}\n/**\n * @param {HTMLElement} parent the parent node\n * @param {HTMLElement} child the child node\n * @param {Window} environment The window context where downshift renders.\n * @return {Boolean} whether the parent is the child or the child is in the parent\n */\n\n\nfunction isOrContainsNode(parent, child, environment) {\n  const result = parent === child || child instanceof environment.Node && parent.contains && parent.contains(child);\n  return result;\n}\n/**\n * Simple debounce implementation. Will call the given\n * function once after the time given has passed since\n * it was last called.\n * @param {Function} fn the function to call after the time\n * @param {Number} time the time to wait\n * @return {Function} the debounced function\n */\n\n\nfunction debounce(fn, time) {\n  let timeoutId;\n\n  function cancel() {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n    }\n  }\n\n  function wrapper() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    cancel();\n    timeoutId = setTimeout(() => {\n      timeoutId = null;\n      fn(...args);\n    }, time);\n  }\n\n  wrapper.cancel = cancel;\n  return wrapper;\n}\n/**\n * This is intended to be used to compose event handlers.\n * They are executed in order until one of them sets\n * `event.preventDownshiftDefault = true`.\n * @param {...Function} fns the event handler functions\n * @return {Function} the event handler to add to an element\n */\n\n\nfunction callAllEventHandlers() {\n  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    fns[_key2] = arguments[_key2];\n  }\n\n  return function (event) {\n    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n      args[_key3 - 1] = arguments[_key3];\n    }\n\n    return fns.some(fn => {\n      if (fn) {\n        fn(event, ...args);\n      }\n\n      return event.preventDownshiftDefault || event.hasOwnProperty('nativeEvent') && event.nativeEvent.preventDownshiftDefault;\n    });\n  };\n}\n\nfunction handleRefs() {\n  for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n    refs[_key4] = arguments[_key4];\n  }\n\n  return node => {\n    refs.forEach(ref => {\n      if (typeof ref === 'function') {\n        ref(node);\n      } else if (ref) {\n        ref.current = node;\n      }\n    });\n  };\n}\n/**\n * This generates a unique ID for an instance of Downshift\n * @return {String} the unique ID\n */\n\n\nfunction generateId() {\n  return String(idCounter++);\n}\n/**\n * Resets idCounter to 0. Used for SSR.\n */\n\n\nfunction resetIdCounter() {\n  idCounter = 0;\n}\n/**\n * Default implementation for status message. Only added when menu is open.\n * Will specify if there are results in the list, and if so, how many,\n * and what keys are relevant.\n *\n * @param {Object} param the downshift state and other relevant properties\n * @return {String} the a11y status message\n */\n\n\nfunction getA11yStatusMessage$1(_ref2) {\n  let {\n    isOpen,\n    resultCount,\n    previousResultCount\n  } = _ref2;\n\n  if (!isOpen) {\n    return '';\n  }\n\n  if (!resultCount) {\n    return 'No results are available.';\n  }\n\n  if (resultCount !== previousResultCount) {\n    return `${resultCount} result${resultCount === 1 ? ' is' : 's are'} available, use up and down arrow keys to navigate. Press Enter key to select.`;\n  }\n\n  return '';\n}\n/**\n * Takes an argument and if it's an array, returns the first item in the array\n * otherwise returns the argument\n * @param {*} arg the maybe-array\n * @param {*} defaultValue the value if arg is falsey not defined\n * @return {*} the arg or it's first item\n */\n\n\nfunction unwrapArray(arg, defaultValue) {\n  arg = Array.isArray(arg) ?\n  /* istanbul ignore next (preact) */\n  arg[0] : arg;\n\n  if (!arg && defaultValue) {\n    return defaultValue;\n  } else {\n    return arg;\n  }\n}\n/**\n * @param {Object} element (P)react element\n * @return {Boolean} whether it's a DOM element\n */\n\n\nfunction isDOMElement(element) {\n\n\n  return typeof element.type === 'string';\n}\n/**\n * @param {Object} element (P)react element\n * @return {Object} the props\n */\n\n\nfunction getElementProps(element) {\n\n  return element.props;\n}\n/**\n * Throws a helpful error message for required properties. Useful\n * to be used as a default in destructuring or object params.\n * @param {String} fnName the function name\n * @param {String} propName the prop name\n */\n\n\nfunction requiredProp(fnName, propName) {\n  // eslint-disable-next-line no-console\n  console.error(`The property \"${propName}\" is required in \"${fnName}\"`);\n}\n\nconst stateKeys = ['highlightedIndex', 'inputValue', 'isOpen', 'selectedItem', 'type'];\n/**\n * @param {Object} state the state object\n * @return {Object} state that is relevant to downshift\n */\n\nfunction pickState(state) {\n  if (state === void 0) {\n    state = {};\n  }\n\n  const result = {};\n  stateKeys.forEach(k => {\n    if (state.hasOwnProperty(k)) {\n      result[k] = state[k];\n    }\n  });\n  return result;\n}\n/**\n * This will perform a shallow merge of the given state object\n * with the state coming from props\n * (for the controlled component scenario)\n * This is used in state updater functions so they're referencing\n * the right state regardless of where it comes from.\n *\n * @param {Object} state The state of the component/hook.\n * @param {Object} props The props that may contain controlled values.\n * @returns {Object} The merged controlled state.\n */\n\n\nfunction getState(state, props) {\n  return Object.keys(state).reduce((prevState, key) => {\n    prevState[key] = isControlledProp(props, key) ? props[key] : state[key];\n    return prevState;\n  }, {});\n}\n/**\n * This determines whether a prop is a \"controlled prop\" meaning it is\n * state which is controlled by the outside of this component rather\n * than within this component.\n *\n * @param {Object} props The props that may contain controlled values.\n * @param {String} key the key to check\n * @return {Boolean} whether it is a controlled controlled prop\n */\n\n\nfunction isControlledProp(props, key) {\n  return props[key] !== undefined;\n}\n/**\n * Normalizes the 'key' property of a KeyboardEvent in IE/Edge\n * @param {Object} event a keyboardEvent object\n * @return {String} keyboard key\n */\n\n\nfunction normalizeArrowKey(event) {\n  const {\n    key,\n    keyCode\n  } = event;\n  /* istanbul ignore next (ie) */\n\n  if (keyCode >= 37 && keyCode <= 40 && key.indexOf('Arrow') !== 0) {\n    return `Arrow${key}`;\n  }\n\n  return key;\n}\n/**\n * Simple check if the value passed is object literal\n * @param {*} obj any things\n * @return {Boolean} whether it's object literal\n */\n\n\nfunction isPlainObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n}\n/**\n * Returns the new index in the list, in a circular way. If next value is out of bonds from the total,\n * it will wrap to either 0 or itemCount - 1.\n *\n * @param {number} moveAmount Number of positions to move. Negative to move backwards, positive forwards.\n * @param {number} baseIndex The initial position to move from.\n * @param {number} itemCount The total number of items.\n * @param {Function} getItemNodeFromIndex Used to check if item is disabled.\n * @param {boolean} circular Specify if navigation is circular. Default is true.\n * @returns {number} The new index after the move.\n */\n\n\nfunction getNextWrappingIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {\n  if (circular === void 0) {\n    circular = true;\n  }\n\n  if (itemCount === 0) {\n    return -1;\n  }\n\n  const itemsLastIndex = itemCount - 1;\n\n  if (typeof baseIndex !== 'number' || baseIndex < 0 || baseIndex >= itemCount) {\n    baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;\n  }\n\n  let newIndex = baseIndex + moveAmount;\n\n  if (newIndex < 0) {\n    newIndex = circular ? itemsLastIndex : 0;\n  } else if (newIndex > itemsLastIndex) {\n    newIndex = circular ? 0 : itemsLastIndex;\n  }\n\n  const nonDisabledNewIndex = getNextNonDisabledIndex(moveAmount, newIndex, itemCount, getItemNodeFromIndex, circular);\n\n  if (nonDisabledNewIndex === -1) {\n    return baseIndex >= itemCount ? -1 : baseIndex;\n  }\n\n  return nonDisabledNewIndex;\n}\n/**\n * Returns the next index in the list of an item that is not disabled.\n *\n * @param {number} moveAmount Number of positions to move. Negative to move backwards, positive forwards.\n * @param {number} baseIndex The initial position to move from.\n * @param {number} itemCount The total number of items.\n * @param {Function} getItemNodeFromIndex Used to check if item is disabled.\n * @param {boolean} circular Specify if navigation is circular. Default is true.\n * @returns {number} The new index. Returns baseIndex if item is not disabled. Returns next non-disabled item otherwise. If no non-disabled found it will return -1.\n */\n\n\nfunction getNextNonDisabledIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {\n  const currentElementNode = getItemNodeFromIndex(baseIndex);\n\n  if (!currentElementNode || !currentElementNode.hasAttribute('disabled')) {\n    return baseIndex;\n  }\n\n  if (moveAmount > 0) {\n    for (let index = baseIndex + 1; index < itemCount; index++) {\n      if (!getItemNodeFromIndex(index).hasAttribute('disabled')) {\n        return index;\n      }\n    }\n  } else {\n    for (let index = baseIndex - 1; index >= 0; index--) {\n      if (!getItemNodeFromIndex(index).hasAttribute('disabled')) {\n        return index;\n      }\n    }\n  }\n\n  if (circular) {\n    return moveAmount > 0 ? getNextNonDisabledIndex(1, 0, itemCount, getItemNodeFromIndex, false) : getNextNonDisabledIndex(-1, itemCount - 1, itemCount, getItemNodeFromIndex, false);\n  }\n\n  return -1;\n}\n/**\n * Checks if event target is within the downshift elements.\n *\n * @param {EventTarget} target Target to check.\n * @param {HTMLElement[]} downshiftElements The elements that form downshift (list, toggle button etc).\n * @param {Window} environment The window context where downshift renders.\n * @param {boolean} checkActiveElement Whether to also check activeElement.\n *\n * @returns {boolean} Whether or not the target is within downshift elements.\n */\n\n\nfunction targetWithinDownshift(target, downshiftElements, environment, checkActiveElement) {\n  if (checkActiveElement === void 0) {\n    checkActiveElement = true;\n  }\n\n  return downshiftElements.some(contextNode => contextNode && (isOrContainsNode(contextNode, target, environment) || checkActiveElement && isOrContainsNode(contextNode, environment.document.activeElement, environment)));\n} // eslint-disable-next-line import/no-mutable-exports\n\n\nlet validateControlledUnchanged = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  validateControlledUnchanged = (state, prevProps, nextProps) => {\n    const warningDescription = `This prop should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Downshift element for the lifetime of the component. More info: https://github.com/downshift-js/downshift#control-props`;\n    Object.keys(state).forEach(propKey => {\n      if (prevProps[propKey] !== undefined && nextProps[propKey] === undefined) {\n        // eslint-disable-next-line no-console\n        console.error(`downshift: A component has changed the controlled prop \"${propKey}\" to be uncontrolled. ${warningDescription}`);\n      } else if (prevProps[propKey] === undefined && nextProps[propKey] !== undefined) {\n        // eslint-disable-next-line no-console\n        console.error(`downshift: A component has changed the uncontrolled prop \"${propKey}\" to be controlled. ${warningDescription}`);\n      }\n    });\n  };\n}\n\nconst cleanupStatus = debounce(documentProp => {\n  getStatusDiv(documentProp).textContent = '';\n}, 500);\n/**\n * @param {String} status the status message\n * @param {Object} documentProp document passed by the user.\n */\n\nfunction setStatus(status, documentProp) {\n  const div = getStatusDiv(documentProp);\n\n  if (!status) {\n    return;\n  }\n\n  div.textContent = status;\n  cleanupStatus(documentProp);\n}\n/**\n * Get the status node or create it if it does not already exist.\n * @param {Object} documentProp document passed by the user.\n * @return {HTMLElement} the status node.\n */\n\n\nfunction getStatusDiv(documentProp) {\n  if (documentProp === void 0) {\n    documentProp = document;\n  }\n\n  let statusDiv = documentProp.getElementById('a11y-status-message');\n\n  if (statusDiv) {\n    return statusDiv;\n  }\n\n  statusDiv = documentProp.createElement('div');\n  statusDiv.setAttribute('id', 'a11y-status-message');\n  statusDiv.setAttribute('role', 'status');\n  statusDiv.setAttribute('aria-live', 'polite');\n  statusDiv.setAttribute('aria-relevant', 'additions text');\n  Object.assign(statusDiv.style, {\n    border: '0',\n    clip: 'rect(0 0 0 0)',\n    height: '1px',\n    margin: '-1px',\n    overflow: 'hidden',\n    padding: '0',\n    position: 'absolute',\n    width: '1px'\n  });\n  documentProp.body.appendChild(statusDiv);\n  return statusDiv;\n}\n\nconst unknown = process.env.NODE_ENV !== \"production\" ? '__autocomplete_unknown__' : 0;\nconst mouseUp = process.env.NODE_ENV !== \"production\" ? '__autocomplete_mouseup__' : 1;\nconst itemMouseEnter = process.env.NODE_ENV !== \"production\" ? '__autocomplete_item_mouseenter__' : 2;\nconst keyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_arrow_up__' : 3;\nconst keyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_arrow_down__' : 4;\nconst keyDownEscape = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_escape__' : 5;\nconst keyDownEnter = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_enter__' : 6;\nconst keyDownHome = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_home__' : 7;\nconst keyDownEnd = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_end__' : 8;\nconst clickItem = process.env.NODE_ENV !== \"production\" ? '__autocomplete_click_item__' : 9;\nconst blurInput = process.env.NODE_ENV !== \"production\" ? '__autocomplete_blur_input__' : 10;\nconst changeInput = process.env.NODE_ENV !== \"production\" ? '__autocomplete_change_input__' : 11;\nconst keyDownSpaceButton = process.env.NODE_ENV !== \"production\" ? '__autocomplete_keydown_space_button__' : 12;\nconst clickButton = process.env.NODE_ENV !== \"production\" ? '__autocomplete_click_button__' : 13;\nconst blurButton = process.env.NODE_ENV !== \"production\" ? '__autocomplete_blur_button__' : 14;\nconst controlledPropUpdatedSelectedItem = process.env.NODE_ENV !== \"production\" ? '__autocomplete_controlled_prop_updated_selected_item__' : 15;\nconst touchEnd = process.env.NODE_ENV !== \"production\" ? '__autocomplete_touchend__' : 16;\n\nvar stateChangeTypes$3 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  unknown: unknown,\n  mouseUp: mouseUp,\n  itemMouseEnter: itemMouseEnter,\n  keyDownArrowUp: keyDownArrowUp,\n  keyDownArrowDown: keyDownArrowDown,\n  keyDownEscape: keyDownEscape,\n  keyDownEnter: keyDownEnter,\n  keyDownHome: keyDownHome,\n  keyDownEnd: keyDownEnd,\n  clickItem: clickItem,\n  blurInput: blurInput,\n  changeInput: changeInput,\n  keyDownSpaceButton: keyDownSpaceButton,\n  clickButton: clickButton,\n  blurButton: blurButton,\n  controlledPropUpdatedSelectedItem: controlledPropUpdatedSelectedItem,\n  touchEnd: touchEnd\n});\n\n/* eslint camelcase:0 */\n\nconst Downshift = /*#__PURE__*/(() => {\n  class Downshift extends Component {\n    constructor(_props) {\n      var _this;\n\n      super(_props);\n      _this = this;\n      this.id = this.props.id || `downshift-${generateId()}`;\n      this.menuId = this.props.menuId || `${this.id}-menu`;\n      this.labelId = this.props.labelId || `${this.id}-label`;\n      this.inputId = this.props.inputId || `${this.id}-input`;\n\n      this.getItemId = this.props.getItemId || (index => `${this.id}-item-${index}`);\n\n      this.input = null;\n      this.items = [];\n      this.itemCount = null;\n      this.previousResultCount = 0;\n      this.timeoutIds = [];\n\n      this.internalSetTimeout = (fn, time) => {\n        const id = setTimeout(() => {\n          this.timeoutIds = this.timeoutIds.filter(i => i !== id);\n          fn();\n        }, time);\n        this.timeoutIds.push(id);\n      };\n\n      this.setItemCount = count => {\n        this.itemCount = count;\n      };\n\n      this.unsetItemCount = () => {\n        this.itemCount = null;\n      };\n\n      this.setHighlightedIndex = function (highlightedIndex, otherStateToSet) {\n        if (highlightedIndex === void 0) {\n          highlightedIndex = _this.props.defaultHighlightedIndex;\n        }\n\n        if (otherStateToSet === void 0) {\n          otherStateToSet = {};\n        }\n\n        otherStateToSet = pickState(otherStateToSet);\n\n        _this.internalSetState({\n          highlightedIndex,\n          ...otherStateToSet\n        });\n      };\n\n      this.clearSelection = cb => {\n        this.internalSetState({\n          selectedItem: null,\n          inputValue: '',\n          highlightedIndex: this.props.defaultHighlightedIndex,\n          isOpen: this.props.defaultIsOpen\n        }, cb);\n      };\n\n      this.selectItem = (item, otherStateToSet, cb) => {\n        otherStateToSet = pickState(otherStateToSet);\n        this.internalSetState({\n          isOpen: this.props.defaultIsOpen,\n          highlightedIndex: this.props.defaultHighlightedIndex,\n          selectedItem: item,\n          inputValue: this.props.itemToString(item),\n          ...otherStateToSet\n        }, cb);\n      };\n\n      this.selectItemAtIndex = (itemIndex, otherStateToSet, cb) => {\n        const item = this.items[itemIndex];\n\n        if (item == null) {\n          return;\n        }\n\n        this.selectItem(item, otherStateToSet, cb);\n      };\n\n      this.selectHighlightedItem = (otherStateToSet, cb) => {\n        return this.selectItemAtIndex(this.getState().highlightedIndex, otherStateToSet, cb);\n      };\n\n      this.internalSetState = (stateToSet, cb) => {\n        let isItemSelected, onChangeArg;\n        const onStateChangeArg = {};\n        const isStateToSetFunction = typeof stateToSet === 'function'; // we want to call `onInputValueChange` before the `setState` call\n        // so someone controlling the `inputValue` state gets notified of\n        // the input change as soon as possible. This avoids issues with\n        // preserving the cursor position.\n        // See https://github.com/downshift-js/downshift/issues/217 for more info.\n\n        if (!isStateToSetFunction && stateToSet.hasOwnProperty('inputValue')) {\n          this.props.onInputValueChange(stateToSet.inputValue, { ...this.getStateAndHelpers(),\n            ...stateToSet\n          });\n        }\n\n        return this.setState(state => {\n          state = this.getState(state);\n          let newStateToSet = isStateToSetFunction ? stateToSet(state) : stateToSet; // Your own function that could modify the state that will be set.\n\n          newStateToSet = this.props.stateReducer(state, newStateToSet); // checks if an item is selected, regardless of if it's different from\n          // what was selected before\n          // used to determine if onSelect and onChange callbacks should be called\n\n          isItemSelected = newStateToSet.hasOwnProperty('selectedItem'); // this keeps track of the object we want to call with setState\n\n          const nextState = {}; // this is just used to tell whether the state changed\n          // and we're trying to update that state. OR if the selection has changed and we're\n          // trying to update the selection\n\n          if (isItemSelected && newStateToSet.selectedItem !== state.selectedItem) {\n            onChangeArg = newStateToSet.selectedItem;\n          }\n\n          newStateToSet.type = newStateToSet.type || unknown;\n          Object.keys(newStateToSet).forEach(key => {\n            // onStateChangeArg should only have the state that is\n            // actually changing\n            if (state[key] !== newStateToSet[key]) {\n              onStateChangeArg[key] = newStateToSet[key];\n            } // the type is useful for the onStateChangeArg\n            // but we don't actually want to set it in internal state.\n            // this is an undocumented feature for now... Not all internalSetState\n            // calls support it and I'm not certain we want them to yet.\n            // But it enables users controlling the isOpen state to know when\n            // the isOpen state changes due to mouseup events which is quite handy.\n\n\n            if (key === 'type') {\n              return;\n            }\n\n            newStateToSet[key]; // if it's coming from props, then we don't care to set it internally\n\n            if (!isControlledProp(this.props, key)) {\n              nextState[key] = newStateToSet[key];\n            }\n          }); // if stateToSet is a function, then we weren't able to call onInputValueChange\n          // earlier, so we'll call it now that we know what the inputValue state will be.\n\n          if (isStateToSetFunction && newStateToSet.hasOwnProperty('inputValue')) {\n            this.props.onInputValueChange(newStateToSet.inputValue, { ...this.getStateAndHelpers(),\n              ...newStateToSet\n            });\n          }\n\n          return nextState;\n        }, () => {\n          // call the provided callback if it's a function\n          cbToCb(cb)(); // only call the onStateChange and onChange callbacks if\n          // we have relevant information to pass them.\n\n          const hasMoreStateThanType = Object.keys(onStateChangeArg).length > 1;\n\n          if (hasMoreStateThanType) {\n            this.props.onStateChange(onStateChangeArg, this.getStateAndHelpers());\n          }\n\n          if (isItemSelected) {\n            this.props.onSelect(stateToSet.selectedItem, this.getStateAndHelpers());\n          }\n\n          if (onChangeArg !== undefined) {\n            this.props.onChange(onChangeArg, this.getStateAndHelpers());\n          } // this is currently undocumented and therefore subject to change\n          // We'll try to not break it, but just be warned.\n\n\n          this.props.onUserAction(onStateChangeArg, this.getStateAndHelpers());\n        });\n      };\n\n      this.rootRef = node => this._rootNode = node;\n\n      this.getRootProps = function (_temp, _temp2) {\n        let {\n          refKey = 'ref',\n          ref,\n          ...rest\n        } = _temp === void 0 ? {} : _temp;\n        let {\n          suppressRefError = false\n        } = _temp2 === void 0 ? {} : _temp2;\n        // this is used in the render to know whether the user has called getRootProps.\n        // It uses that to know whether to apply the props automatically\n        _this.getRootProps.called = true;\n        _this.getRootProps.refKey = refKey;\n        _this.getRootProps.suppressRefError = suppressRefError;\n\n        const {\n          isOpen\n        } = _this.getState();\n\n        return {\n          [refKey]: handleRefs(ref, _this.rootRef),\n          role: 'combobox',\n          'aria-expanded': isOpen,\n          'aria-haspopup': 'listbox',\n          'aria-owns': isOpen ? _this.menuId : null,\n          'aria-labelledby': _this.labelId,\n          ...rest\n        };\n      };\n\n      this.keyDownHandlers = {\n        ArrowDown(event) {\n          event.preventDefault();\n\n          if (this.getState().isOpen) {\n            const amount = event.shiftKey ? 5 : 1;\n            this.moveHighlightedIndex(amount, {\n              type: keyDownArrowDown\n            });\n          } else {\n            this.internalSetState({\n              isOpen: true,\n              type: keyDownArrowDown\n            }, () => {\n              const itemCount = this.getItemCount();\n\n              if (itemCount > 0) {\n                const {\n                  highlightedIndex\n                } = this.getState();\n                const nextHighlightedIndex = getNextWrappingIndex(1, highlightedIndex, itemCount, index => this.getItemNodeFromIndex(index));\n                this.setHighlightedIndex(nextHighlightedIndex, {\n                  type: keyDownArrowDown\n                });\n              }\n            });\n          }\n        },\n\n        ArrowUp(event) {\n          event.preventDefault();\n\n          if (this.getState().isOpen) {\n            const amount = event.shiftKey ? -5 : -1;\n            this.moveHighlightedIndex(amount, {\n              type: keyDownArrowUp\n            });\n          } else {\n            this.internalSetState({\n              isOpen: true,\n              type: keyDownArrowUp\n            }, () => {\n              const itemCount = this.getItemCount();\n\n              if (itemCount > 0) {\n                const {\n                  highlightedIndex\n                } = this.getState();\n                const nextHighlightedIndex = getNextWrappingIndex(-1, highlightedIndex, itemCount, index => this.getItemNodeFromIndex(index));\n                this.setHighlightedIndex(nextHighlightedIndex, {\n                  type: keyDownArrowUp\n                });\n              }\n            });\n          }\n        },\n\n        Enter(event) {\n          if (event.which === 229) {\n            return;\n          }\n\n          const {\n            isOpen,\n            highlightedIndex\n          } = this.getState();\n\n          if (isOpen && highlightedIndex != null) {\n            event.preventDefault();\n            const item = this.items[highlightedIndex];\n            const itemNode = this.getItemNodeFromIndex(highlightedIndex);\n\n            if (item == null || itemNode && itemNode.hasAttribute('disabled')) {\n              return;\n            }\n\n            this.selectHighlightedItem({\n              type: keyDownEnter\n            });\n          }\n        },\n\n        Escape(event) {\n          event.preventDefault();\n          this.reset({\n            type: keyDownEscape,\n            ...(!this.state.isOpen && {\n              selectedItem: null,\n              inputValue: ''\n            })\n          });\n        }\n\n      };\n      this.buttonKeyDownHandlers = { ...this.keyDownHandlers,\n\n        ' '(event) {\n          event.preventDefault();\n          this.toggleMenu({\n            type: keyDownSpaceButton\n          });\n        }\n\n      };\n      this.inputKeyDownHandlers = { ...this.keyDownHandlers,\n\n        Home(event) {\n          const {\n            isOpen\n          } = this.getState();\n\n          if (!isOpen) {\n            return;\n          }\n\n          event.preventDefault();\n          const itemCount = this.getItemCount();\n\n          if (itemCount <= 0 || !isOpen) {\n            return;\n          } // get next non-disabled starting downwards from 0 if that's disabled.\n\n\n          const newHighlightedIndex = getNextNonDisabledIndex(1, 0, itemCount, index => this.getItemNodeFromIndex(index), false);\n          this.setHighlightedIndex(newHighlightedIndex, {\n            type: keyDownHome\n          });\n        },\n\n        End(event) {\n          const {\n            isOpen\n          } = this.getState();\n\n          if (!isOpen) {\n            return;\n          }\n\n          event.preventDefault();\n          const itemCount = this.getItemCount();\n\n          if (itemCount <= 0 || !isOpen) {\n            return;\n          } // get next non-disabled starting upwards from last index if that's disabled.\n\n\n          const newHighlightedIndex = getNextNonDisabledIndex(-1, itemCount - 1, itemCount, index => this.getItemNodeFromIndex(index), false);\n          this.setHighlightedIndex(newHighlightedIndex, {\n            type: keyDownEnd\n          });\n        }\n\n      };\n\n      this.getToggleButtonProps = function (_temp3) {\n        let {\n          onClick,\n          onPress,\n          onKeyDown,\n          onKeyUp,\n          onBlur,\n          ...rest\n        } = _temp3 === void 0 ? {} : _temp3;\n\n        const {\n          isOpen\n        } = _this.getState();\n\n        const enabledEventHandlers = {\n          onClick: callAllEventHandlers(onClick, _this.buttonHandleClick),\n          onKeyDown: callAllEventHandlers(onKeyDown, _this.buttonHandleKeyDown),\n          onKeyUp: callAllEventHandlers(onKeyUp, _this.buttonHandleKeyUp),\n          onBlur: callAllEventHandlers(onBlur, _this.buttonHandleBlur)\n        };\n        const eventHandlers = rest.disabled ? {} : enabledEventHandlers;\n        return {\n          type: 'button',\n          role: 'button',\n          'aria-label': isOpen ? 'close menu' : 'open menu',\n          'aria-haspopup': true,\n          'data-toggle': true,\n          ...eventHandlers,\n          ...rest\n        };\n      };\n\n      this.buttonHandleKeyUp = event => {\n        // Prevent click event from emitting in Firefox\n        event.preventDefault();\n      };\n\n      this.buttonHandleKeyDown = event => {\n        const key = normalizeArrowKey(event);\n\n        if (this.buttonKeyDownHandlers[key]) {\n          this.buttonKeyDownHandlers[key].call(this, event);\n        }\n      };\n\n      this.buttonHandleClick = event => {\n        event.preventDefault(); // handle odd case for Safari and Firefox which\n        // don't give the button the focus properly.\n\n        /* istanbul ignore if (can't reasonably test this) */\n\n        if (this.props.environment.document.activeElement === this.props.environment.document.body) {\n          event.target.focus();\n        } // to simplify testing components that use downshift, we'll not wrap this in a setTimeout\n        // if the NODE_ENV is test. With the proper build system, this should be dead code eliminated\n        // when building for production and should therefore have no impact on production code.\n\n\n        if (process.env.NODE_ENV === 'test') {\n          this.toggleMenu({\n            type: clickButton\n          });\n        } else {\n          // Ensure that toggle of menu occurs after the potential blur event in iOS\n          this.internalSetTimeout(() => this.toggleMenu({\n            type: clickButton\n          }));\n        }\n      };\n\n      this.buttonHandleBlur = event => {\n        const blurTarget = event.target; // Save blur target for comparison with activeElement later\n        // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not body element\n\n        this.internalSetTimeout(() => {\n          if (!this.isMouseDown && (this.props.environment.document.activeElement == null || this.props.environment.document.activeElement.id !== this.inputId) && this.props.environment.document.activeElement !== blurTarget // Do nothing if we refocus the same element again (to solve issue in Safari on iOS)\n          ) {\n            this.reset({\n              type: blurButton\n            });\n          }\n        });\n      };\n\n      this.getLabelProps = props => {\n        return {\n          htmlFor: this.inputId,\n          id: this.labelId,\n          ...props\n        };\n      };\n\n      this.getInputProps = function (_temp4) {\n        let {\n          onKeyDown,\n          onBlur,\n          onChange,\n          onInput,\n          onChangeText,\n          ...rest\n        } = _temp4 === void 0 ? {} : _temp4;\n        let onChangeKey;\n        let eventHandlers = {};\n        /* istanbul ignore next (preact) */\n\n        {\n          onChangeKey = 'onChange';\n        }\n\n        const {\n          inputValue,\n          isOpen,\n          highlightedIndex\n        } = _this.getState();\n\n        if (!rest.disabled) {\n          eventHandlers = {\n            [onChangeKey]: callAllEventHandlers(onChange, onInput, _this.inputHandleChange),\n            onKeyDown: callAllEventHandlers(onKeyDown, _this.inputHandleKeyDown),\n            onBlur: callAllEventHandlers(onBlur, _this.inputHandleBlur)\n          };\n        }\n\n        return {\n          'aria-autocomplete': 'list',\n          'aria-activedescendant': isOpen && typeof highlightedIndex === 'number' && highlightedIndex >= 0 ? _this.getItemId(highlightedIndex) : null,\n          'aria-controls': isOpen ? _this.menuId : null,\n          'aria-labelledby': _this.labelId,\n          // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion\n          // revert back since autocomplete=\"nope\" is ignored on latest Chrome and Opera\n          autoComplete: 'off',\n          value: inputValue,\n          id: _this.inputId,\n          ...eventHandlers,\n          ...rest\n        };\n      };\n\n      this.inputHandleKeyDown = event => {\n        const key = normalizeArrowKey(event);\n\n        if (key && this.inputKeyDownHandlers[key]) {\n          this.inputKeyDownHandlers[key].call(this, event);\n        }\n      };\n\n      this.inputHandleChange = event => {\n        this.internalSetState({\n          type: changeInput,\n          isOpen: true,\n          inputValue: event.target.value,\n          highlightedIndex: this.props.defaultHighlightedIndex\n        });\n      };\n\n      this.inputHandleBlur = () => {\n        // Need setTimeout, so that when the user presses Tab, the activeElement is the next focused element, not the body element\n        this.internalSetTimeout(() => {\n          const downshiftButtonIsActive = this.props.environment.document && !!this.props.environment.document.activeElement && !!this.props.environment.document.activeElement.dataset && this.props.environment.document.activeElement.dataset.toggle && this._rootNode && this._rootNode.contains(this.props.environment.document.activeElement);\n\n          if (!this.isMouseDown && !downshiftButtonIsActive) {\n            this.reset({\n              type: blurInput\n            });\n          }\n        });\n      };\n\n      this.menuRef = node => {\n        this._menuNode = node;\n      };\n\n      this.getMenuProps = function (_temp5, _temp6) {\n        let {\n          refKey = 'ref',\n          ref,\n          ...props\n        } = _temp5 === void 0 ? {} : _temp5;\n        let {\n          suppressRefError = false\n        } = _temp6 === void 0 ? {} : _temp6;\n        _this.getMenuProps.called = true;\n        _this.getMenuProps.refKey = refKey;\n        _this.getMenuProps.suppressRefError = suppressRefError;\n        return {\n          [refKey]: handleRefs(ref, _this.menuRef),\n          role: 'listbox',\n          'aria-labelledby': props && props['aria-label'] ? null : _this.labelId,\n          id: _this.menuId,\n          ...props\n        };\n      };\n\n      this.getItemProps = function (_temp7) {\n        let {\n          onMouseMove,\n          onMouseDown,\n          onClick,\n          onPress,\n          index,\n          item = process.env.NODE_ENV === 'production' ?\n          /* istanbul ignore next */\n          undefined : requiredProp('getItemProps', 'item'),\n          ...rest\n        } = _temp7 === void 0 ? {} : _temp7;\n\n        if (index === undefined) {\n          _this.items.push(item);\n\n          index = _this.items.indexOf(item);\n        } else {\n          _this.items[index] = item;\n        }\n\n        const onSelectKey = 'onClick';\n        const customClickHandler = onClick;\n        const enabledEventHandlers = {\n          // onMouseMove is used over onMouseEnter here. onMouseMove\n          // is only triggered on actual mouse movement while onMouseEnter\n          // can fire on DOM changes, interrupting keyboard navigation\n          onMouseMove: callAllEventHandlers(onMouseMove, () => {\n            if (index === _this.getState().highlightedIndex) {\n              return;\n            }\n\n            _this.setHighlightedIndex(index, {\n              type: itemMouseEnter\n            }); // We never want to manually scroll when changing state based\n            // on `onMouseMove` because we will be moving the element out\n            // from under the user which is currently scrolling/moving the\n            // cursor\n\n\n            _this.avoidScrolling = true;\n\n            _this.internalSetTimeout(() => _this.avoidScrolling = false, 250);\n          }),\n          onMouseDown: callAllEventHandlers(onMouseDown, event => {\n            // This prevents the activeElement from being changed\n            // to the item so it can remain with the current activeElement\n            // which is a more common use case.\n            event.preventDefault();\n          }),\n          [onSelectKey]: callAllEventHandlers(customClickHandler, () => {\n            _this.selectItemAtIndex(index, {\n              type: clickItem\n            });\n          })\n        }; // Passing down the onMouseDown handler to prevent redirect\n        // of the activeElement if clicking on disabled items\n\n        const eventHandlers = rest.disabled ? {\n          onMouseDown: enabledEventHandlers.onMouseDown\n        } : enabledEventHandlers;\n        return {\n          id: _this.getItemId(index),\n          role: 'option',\n          'aria-selected': _this.getState().highlightedIndex === index,\n          ...eventHandlers,\n          ...rest\n        };\n      };\n\n      this.clearItems = () => {\n        this.items = [];\n      };\n\n      this.reset = function (otherStateToSet, cb) {\n        if (otherStateToSet === void 0) {\n          otherStateToSet = {};\n        }\n\n        otherStateToSet = pickState(otherStateToSet);\n\n        _this.internalSetState(_ref => {\n          let {\n            selectedItem\n          } = _ref;\n          return {\n            isOpen: _this.props.defaultIsOpen,\n            highlightedIndex: _this.props.defaultHighlightedIndex,\n            inputValue: _this.props.itemToString(selectedItem),\n            ...otherStateToSet\n          };\n        }, cb);\n      };\n\n      this.toggleMenu = function (otherStateToSet, cb) {\n        if (otherStateToSet === void 0) {\n          otherStateToSet = {};\n        }\n\n        otherStateToSet = pickState(otherStateToSet);\n\n        _this.internalSetState(_ref2 => {\n          let {\n            isOpen\n          } = _ref2;\n          return {\n            isOpen: !isOpen,\n            ...(isOpen && {\n              highlightedIndex: _this.props.defaultHighlightedIndex\n            }),\n            ...otherStateToSet\n          };\n        }, () => {\n          const {\n            isOpen,\n            highlightedIndex\n          } = _this.getState();\n\n          if (isOpen) {\n            if (_this.getItemCount() > 0 && typeof highlightedIndex === 'number') {\n              _this.setHighlightedIndex(highlightedIndex, otherStateToSet);\n            }\n          }\n\n          cbToCb(cb)();\n        });\n      };\n\n      this.openMenu = cb => {\n        this.internalSetState({\n          isOpen: true\n        }, cb);\n      };\n\n      this.closeMenu = cb => {\n        this.internalSetState({\n          isOpen: false\n        }, cb);\n      };\n\n      this.updateStatus = debounce(() => {\n        const state = this.getState();\n        const item = this.items[state.highlightedIndex];\n        const resultCount = this.getItemCount();\n        const status = this.props.getA11yStatusMessage({\n          itemToString: this.props.itemToString,\n          previousResultCount: this.previousResultCount,\n          resultCount,\n          highlightedItem: item,\n          ...state\n        });\n        this.previousResultCount = resultCount;\n        setStatus(status, this.props.environment.document);\n      }, 200);\n      // fancy destructuring + defaults + aliases\n      // this basically says each value of state should either be set to\n      // the initial value or the default value if the initial value is not provided\n      const {\n        defaultHighlightedIndex,\n        initialHighlightedIndex: _highlightedIndex = defaultHighlightedIndex,\n        defaultIsOpen,\n        initialIsOpen: _isOpen = defaultIsOpen,\n        initialInputValue: _inputValue = '',\n        initialSelectedItem: _selectedItem = null\n      } = this.props;\n\n      const _state = this.getState({\n        highlightedIndex: _highlightedIndex,\n        isOpen: _isOpen,\n        inputValue: _inputValue,\n        selectedItem: _selectedItem\n      });\n\n      if (_state.selectedItem != null && this.props.initialInputValue === undefined) {\n        _state.inputValue = this.props.itemToString(_state.selectedItem);\n      }\n\n      this.state = _state;\n    }\n\n    /**\n     * Clear all running timeouts\n     */\n    internalClearTimeouts() {\n      this.timeoutIds.forEach(id => {\n        clearTimeout(id);\n      });\n      this.timeoutIds = [];\n    }\n    /**\n     * Gets the state based on internal state or props\n     * If a state value is passed via props, then that\n     * is the value given, otherwise it's retrieved from\n     * stateToMerge\n     *\n     * @param {Object} stateToMerge defaults to this.state\n     * @return {Object} the state\n     */\n\n\n    getState(stateToMerge) {\n      if (stateToMerge === void 0) {\n        stateToMerge = this.state;\n      }\n\n      return getState(stateToMerge, this.props);\n    }\n\n    getItemCount() {\n      // things read better this way. They're in priority order:\n      // 1. `this.itemCount`\n      // 2. `this.props.itemCount`\n      // 3. `this.items.length`\n      let itemCount = this.items.length;\n\n      if (this.itemCount != null) {\n        itemCount = this.itemCount;\n      } else if (this.props.itemCount !== undefined) {\n        itemCount = this.props.itemCount;\n      }\n\n      return itemCount;\n    }\n\n    getItemNodeFromIndex(index) {\n      return this.props.environment.document.getElementById(this.getItemId(index));\n    }\n\n    scrollHighlightedItemIntoView() {\n      /* istanbul ignore else (react-native) */\n      {\n        const node = this.getItemNodeFromIndex(this.getState().highlightedIndex);\n        this.props.scrollIntoView(node, this._menuNode);\n      }\n    }\n\n    moveHighlightedIndex(amount, otherStateToSet) {\n      const itemCount = this.getItemCount();\n      const {\n        highlightedIndex\n      } = this.getState();\n\n      if (itemCount > 0) {\n        const nextHighlightedIndex = getNextWrappingIndex(amount, highlightedIndex, itemCount, index => this.getItemNodeFromIndex(index));\n        this.setHighlightedIndex(nextHighlightedIndex, otherStateToSet);\n      }\n    }\n\n    getStateAndHelpers() {\n      const {\n        highlightedIndex,\n        inputValue,\n        selectedItem,\n        isOpen\n      } = this.getState();\n      const {\n        itemToString\n      } = this.props;\n      const {\n        id\n      } = this;\n      const {\n        getRootProps,\n        getToggleButtonProps,\n        getLabelProps,\n        getMenuProps,\n        getInputProps,\n        getItemProps,\n        openMenu,\n        closeMenu,\n        toggleMenu,\n        selectItem,\n        selectItemAtIndex,\n        selectHighlightedItem,\n        setHighlightedIndex,\n        clearSelection,\n        clearItems,\n        reset,\n        setItemCount,\n        unsetItemCount,\n        internalSetState: setState\n      } = this;\n      return {\n        // prop getters\n        getRootProps,\n        getToggleButtonProps,\n        getLabelProps,\n        getMenuProps,\n        getInputProps,\n        getItemProps,\n        // actions\n        reset,\n        openMenu,\n        closeMenu,\n        toggleMenu,\n        selectItem,\n        selectItemAtIndex,\n        selectHighlightedItem,\n        setHighlightedIndex,\n        clearSelection,\n        clearItems,\n        setItemCount,\n        unsetItemCount,\n        setState,\n        // props\n        itemToString,\n        // derived\n        id,\n        // state\n        highlightedIndex,\n        inputValue,\n        isOpen,\n        selectedItem\n      };\n    } //////////////////////////// ROOT\n\n\n    componentDidMount() {\n      /* istanbul ignore if (react-native) */\n      if (process.env.NODE_ENV !== 'production' && !false && this.getMenuProps.called && !this.getMenuProps.suppressRefError) {\n        validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);\n      }\n      /* istanbul ignore if (react-native) */\n\n\n      {\n        // this.isMouseDown helps us track whether the mouse is currently held down.\n        // This is useful when the user clicks on an item in the list, but holds the mouse\n        // down long enough for the list to disappear (because the blur event fires on the input)\n        // this.isMouseDown is used in the blur handler on the input to determine whether the blur event should\n        // trigger hiding the menu.\n        const onMouseDown = () => {\n          this.isMouseDown = true;\n        };\n\n        const onMouseUp = event => {\n          this.isMouseDown = false; // if the target element or the activeElement is within a downshift node\n          // then we don't want to reset downshift\n\n          const contextWithinDownshift = targetWithinDownshift(event.target, [this._rootNode, this._menuNode], this.props.environment);\n\n          if (!contextWithinDownshift && this.getState().isOpen) {\n            this.reset({\n              type: mouseUp\n            }, () => this.props.onOuterClick(this.getStateAndHelpers()));\n          }\n        }; // Touching an element in iOS gives focus and hover states, but touching out of\n        // the element will remove hover, and persist the focus state, resulting in the\n        // blur event not being triggered.\n        // this.isTouchMove helps us track whether the user is tapping or swiping on a touch screen.\n        // If the user taps outside of Downshift, the component should be reset,\n        // but not if the user is swiping\n\n\n        const onTouchStart = () => {\n          this.isTouchMove = false;\n        };\n\n        const onTouchMove = () => {\n          this.isTouchMove = true;\n        };\n\n        const onTouchEnd = event => {\n          const contextWithinDownshift = targetWithinDownshift(event.target, [this._rootNode, this._menuNode], this.props.environment, false);\n\n          if (!this.isTouchMove && !contextWithinDownshift && this.getState().isOpen) {\n            this.reset({\n              type: touchEnd\n            }, () => this.props.onOuterClick(this.getStateAndHelpers()));\n          }\n        };\n\n        const {\n          environment\n        } = this.props;\n        environment.addEventListener('mousedown', onMouseDown);\n        environment.addEventListener('mouseup', onMouseUp);\n        environment.addEventListener('touchstart', onTouchStart);\n        environment.addEventListener('touchmove', onTouchMove);\n        environment.addEventListener('touchend', onTouchEnd);\n\n        this.cleanup = () => {\n          this.internalClearTimeouts();\n          this.updateStatus.cancel();\n          environment.removeEventListener('mousedown', onMouseDown);\n          environment.removeEventListener('mouseup', onMouseUp);\n          environment.removeEventListener('touchstart', onTouchStart);\n          environment.removeEventListener('touchmove', onTouchMove);\n          environment.removeEventListener('touchend', onTouchEnd);\n        };\n      }\n    }\n\n    shouldScroll(prevState, prevProps) {\n      const {\n        highlightedIndex: currentHighlightedIndex\n      } = this.props.highlightedIndex === undefined ? this.getState() : this.props;\n      const {\n        highlightedIndex: prevHighlightedIndex\n      } = prevProps.highlightedIndex === undefined ? prevState : prevProps;\n      const scrollWhenOpen = currentHighlightedIndex && this.getState().isOpen && !prevState.isOpen;\n      const scrollWhenNavigating = currentHighlightedIndex !== prevHighlightedIndex;\n      return scrollWhenOpen || scrollWhenNavigating;\n    }\n\n    componentDidUpdate(prevProps, prevState) {\n      if (process.env.NODE_ENV !== 'production') {\n        validateControlledUnchanged(this.state, prevProps, this.props);\n        /* istanbul ignore if (react-native) */\n\n        if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {\n          validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);\n        }\n      }\n\n      if (isControlledProp(this.props, 'selectedItem') && this.props.selectedItemChanged(prevProps.selectedItem, this.props.selectedItem)) {\n        this.internalSetState({\n          type: controlledPropUpdatedSelectedItem,\n          inputValue: this.props.itemToString(this.props.selectedItem)\n        });\n      }\n\n      if (!this.avoidScrolling && this.shouldScroll(prevState, prevProps)) {\n        this.scrollHighlightedItemIntoView();\n      }\n      /* istanbul ignore else (react-native) */\n\n\n      {\n        this.updateStatus();\n      }\n    }\n\n    componentWillUnmount() {\n      this.cleanup(); // avoids memory leak\n    }\n\n    render() {\n      const children = unwrapArray(this.props.children, noop); // because the items are rerendered every time we call the children\n      // we clear this out each render and it will be populated again as\n      // getItemProps is called.\n\n      this.clearItems(); // we reset this so we know whether the user calls getRootProps during\n      // this render. If they do then we don't need to do anything,\n      // if they don't then we need to clone the element they return and\n      // apply the props for them.\n\n      this.getRootProps.called = false;\n      this.getRootProps.refKey = undefined;\n      this.getRootProps.suppressRefError = undefined; // we do something similar for getMenuProps\n\n      this.getMenuProps.called = false;\n      this.getMenuProps.refKey = undefined;\n      this.getMenuProps.suppressRefError = undefined; // we do something similar for getLabelProps\n\n      this.getLabelProps.called = false; // and something similar for getInputProps\n\n      this.getInputProps.called = false;\n      const element = unwrapArray(children(this.getStateAndHelpers()));\n\n      if (!element) {\n        return null;\n      }\n\n      if (this.getRootProps.called || this.props.suppressRefError) {\n        if (process.env.NODE_ENV !== 'production' && !this.getRootProps.suppressRefError && !this.props.suppressRefError) {\n          validateGetRootPropsCalledCorrectly(element, this.getRootProps);\n        }\n\n        return element;\n      } else if (isDOMElement(element)) {\n        // they didn't apply the root props, but we can clone\n        // this and apply the props ourselves\n        return /*#__PURE__*/cloneElement(element, this.getRootProps(getElementProps(element)));\n      }\n      /* istanbul ignore else */\n\n\n      if (process.env.NODE_ENV !== 'production') {\n        // they didn't apply the root props, but they need to\n        // otherwise we can't query around the autocomplete\n        throw new Error('downshift: If you return a non-DOM element, you must apply the getRootProps function');\n      }\n      /* istanbul ignore next */\n\n\n      return undefined;\n    }\n\n  }\n\n  Downshift.defaultProps = {\n    defaultHighlightedIndex: null,\n    defaultIsOpen: false,\n    getA11yStatusMessage: getA11yStatusMessage$1,\n    itemToString: i => {\n      if (i == null) {\n        return '';\n      }\n\n      if (process.env.NODE_ENV !== 'production' && isPlainObject(i) && !i.hasOwnProperty('toString')) {\n        // eslint-disable-next-line no-console\n        console.warn('downshift: An object was passed to the default implementation of `itemToString`. You should probably provide your own `itemToString` implementation. Please refer to the `itemToString` API documentation.', 'The object that was passed:', i);\n      }\n\n      return String(i);\n    },\n    onStateChange: noop,\n    onInputValueChange: noop,\n    onUserAction: noop,\n    onChange: noop,\n    onSelect: noop,\n    onOuterClick: noop,\n    selectedItemChanged: (prevItem, item) => prevItem !== item,\n    environment:\n    /* istanbul ignore next (ssr) */\n    typeof window === 'undefined' ? {} : window,\n    stateReducer: (state, stateToSet) => stateToSet,\n    suppressRefError: false,\n    scrollIntoView\n  };\n  Downshift.stateChangeTypes = stateChangeTypes$3;\n  return Downshift;\n})();\n\nprocess.env.NODE_ENV !== \"production\" ? Downshift.propTypes = {\n  children: PropTypes.func,\n  defaultHighlightedIndex: PropTypes.number,\n  defaultIsOpen: PropTypes.bool,\n  initialHighlightedIndex: PropTypes.number,\n  initialSelectedItem: PropTypes.any,\n  initialInputValue: PropTypes.string,\n  initialIsOpen: PropTypes.bool,\n  getA11yStatusMessage: PropTypes.func,\n  itemToString: PropTypes.func,\n  onChange: PropTypes.func,\n  onSelect: PropTypes.func,\n  onStateChange: PropTypes.func,\n  onInputValueChange: PropTypes.func,\n  onUserAction: PropTypes.func,\n  onOuterClick: PropTypes.func,\n  selectedItemChanged: PropTypes.func,\n  stateReducer: PropTypes.func,\n  itemCount: PropTypes.number,\n  id: PropTypes.string,\n  environment: PropTypes.shape({\n    addEventListener: PropTypes.func,\n    removeEventListener: PropTypes.func,\n    document: PropTypes.shape({\n      getElementById: PropTypes.func,\n      activeElement: PropTypes.any,\n      body: PropTypes.any\n    })\n  }),\n  suppressRefError: PropTypes.bool,\n  scrollIntoView: PropTypes.func,\n  // things we keep in state for uncontrolled components\n  // but can accept as props for controlled components\n\n  /* eslint-disable react/no-unused-prop-types */\n  selectedItem: PropTypes.any,\n  isOpen: PropTypes.bool,\n  inputValue: PropTypes.string,\n  highlightedIndex: PropTypes.number,\n  labelId: PropTypes.string,\n  inputId: PropTypes.string,\n  menuId: PropTypes.string,\n  getItemId: PropTypes.func\n  /* eslint-enable react/no-unused-prop-types */\n\n} : void 0;\nvar Downshift$1 = Downshift;\n\nfunction validateGetMenuPropsCalledCorrectly(node, _ref3) {\n  let {\n    refKey\n  } = _ref3;\n\n  if (!node) {\n    // eslint-disable-next-line no-console\n    console.error(`downshift: The ref prop \"${refKey}\" from getMenuProps was not applied correctly on your menu element.`);\n  }\n}\n\nfunction validateGetRootPropsCalledCorrectly(element, _ref4) {\n  let {\n    refKey\n  } = _ref4;\n  const refKeySpecified = refKey !== 'ref';\n  const isComposite = !isDOMElement(element);\n\n  if (isComposite && !refKeySpecified && !isForwardRef(element)) {\n    // eslint-disable-next-line no-console\n    console.error('downshift: You returned a non-DOM element. You must specify a refKey in getRootProps');\n  } else if (!isComposite && refKeySpecified) {\n    // eslint-disable-next-line no-console\n    console.error(`downshift: You returned a DOM element. You should not specify a refKey in getRootProps. You specified \"${refKey}\"`);\n  }\n\n  if (!isForwardRef(element) && !getElementProps(element)[refKey]) {\n    // eslint-disable-next-line no-console\n    console.error(`downshift: You must apply the ref prop \"${refKey}\" from getRootProps onto your root element.`);\n  }\n}\n\nconst dropdownDefaultStateValues = {\n  highlightedIndex: -1,\n  isOpen: false,\n  selectedItem: null,\n  inputValue: ''\n};\n\nfunction callOnChangeProps(action, state, newState) {\n  const {\n    props,\n    type\n  } = action;\n  const changes = {};\n  Object.keys(state).forEach(key => {\n    invokeOnChangeHandler(key, action, state, newState);\n\n    if (newState[key] !== state[key]) {\n      changes[key] = newState[key];\n    }\n  });\n\n  if (props.onStateChange && Object.keys(changes).length) {\n    props.onStateChange({\n      type,\n      ...changes\n    });\n  }\n}\n\nfunction invokeOnChangeHandler(key, action, state, newState) {\n  const {\n    props,\n    type\n  } = action;\n  const handler = `on${capitalizeString(key)}Change`;\n\n  if (props[handler] && newState[key] !== undefined && newState[key] !== state[key]) {\n    props[handler]({\n      type,\n      ...newState\n    });\n  }\n}\n/**\n * Default state reducer that returns the changes.\n *\n * @param {Object} s state.\n * @param {Object} a action with changes.\n * @returns {Object} changes.\n */\n\n\nfunction stateReducer(s, a) {\n  return a.changes;\n}\n/**\n * Returns a message to be added to aria-live region when item is selected.\n *\n * @param {Object} selectionParameters Parameters required to build the message.\n * @returns {string} The a11y message.\n */\n\n\nfunction getA11ySelectionMessage(selectionParameters) {\n  const {\n    selectedItem,\n    itemToString: itemToStringLocal\n  } = selectionParameters;\n  return selectedItem ? `${itemToStringLocal(selectedItem)} has been selected.` : '';\n}\n/**\n * Debounced call for updating the a11y message.\n */\n\n\nconst updateA11yStatus = debounce((getA11yMessage, document) => {\n  setStatus(getA11yMessage(), document);\n}, 200); // istanbul ignore next\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined' ? useLayoutEffect : useEffect;\n\nfunction useElementIds(_ref) {\n  let {\n    id = `downshift-${generateId()}`,\n    labelId,\n    menuId,\n    getItemId,\n    toggleButtonId,\n    inputId\n  } = _ref;\n  const elementIdsRef = useRef({\n    labelId: labelId || `${id}-label`,\n    menuId: menuId || `${id}-menu`,\n    getItemId: getItemId || (index => `${id}-item-${index}`),\n    toggleButtonId: toggleButtonId || `${id}-toggle-button`,\n    inputId: inputId || `${id}-input`\n  });\n  return elementIdsRef.current;\n}\n\nfunction getItemIndex(index, item, items) {\n  if (index !== undefined) {\n    return index;\n  }\n\n  if (items.length === 0) {\n    return -1;\n  }\n\n  return items.indexOf(item);\n}\n\nfunction itemToString(item) {\n  return item ? String(item) : '';\n}\n\nfunction isAcceptedCharacterKey(key) {\n  return /^\\S{1}$/.test(key);\n}\n\nfunction capitalizeString(string) {\n  return `${string.slice(0, 1).toUpperCase()}${string.slice(1)}`;\n}\n\nfunction useLatestRef(val) {\n  const ref = useRef(val); // technically this is not \"concurrent mode safe\" because we're manipulating\n  // the value during render (so it's not idempotent). However, the places this\n  // hook is used is to support memoizing callbacks which will be called\n  // *during* render, so we need the latest values *during* render.\n  // If not for this, then we'd probably want to use useLayoutEffect instead.\n\n  ref.current = val;\n  return ref;\n}\n/**\n * Computes the controlled state using a the previous state, props,\n * two reducers, one from downshift and an optional one from the user.\n * Also calls the onChange handlers for state values that have changed.\n *\n * @param {Function} reducer Reducer function from downshift.\n * @param {Object} initialState Initial state of the hook.\n * @param {Object} props The hook props.\n * @returns {Array} An array with the state and an action dispatcher.\n */\n\n\nfunction useEnhancedReducer(reducer, initialState, props) {\n  const prevStateRef = useRef();\n  const actionRef = useRef();\n  const enhancedReducer = useCallback((state, action) => {\n    actionRef.current = action;\n    state = getState(state, action.props);\n    const changes = reducer(state, action);\n    const newState = action.props.stateReducer(state, { ...action,\n      changes\n    });\n    return newState;\n  }, [reducer]);\n  const [state, dispatch] = useReducer(enhancedReducer, initialState);\n  const propsRef = useLatestRef(props);\n  const dispatchWithProps = useCallback(action => dispatch({\n    props: propsRef.current,\n    ...action\n  }), [propsRef]);\n  const action = actionRef.current;\n  useEffect(() => {\n    if (action && prevStateRef.current && prevStateRef.current !== state) {\n      callOnChangeProps(action, getState(prevStateRef.current, action.props), state);\n    }\n\n    prevStateRef.current = state;\n  }, [state, props, action]);\n  return [state, dispatchWithProps];\n}\n/**\n * Wraps the useEnhancedReducer and applies the controlled prop values before\n * returning the new state.\n *\n * @param {Function} reducer Reducer function from downshift.\n * @param {Object} initialState Initial state of the hook.\n * @param {Object} props The hook props.\n * @returns {Array} An array with the state and an action dispatcher.\n */\n\n\nfunction useControlledReducer$1(reducer, initialState, props) {\n  const [state, dispatch] = useEnhancedReducer(reducer, initialState, props);\n  return [getState(state, props), dispatch];\n}\n\nconst defaultProps$3 = {\n  itemToString,\n  stateReducer,\n  getA11ySelectionMessage,\n  scrollIntoView,\n  circularNavigation: false,\n  environment:\n  /* istanbul ignore next (ssr) */\n  typeof window === 'undefined' ? {} : window\n};\n\nfunction getDefaultValue$1(props, propKey, defaultStateValues) {\n  if (defaultStateValues === void 0) {\n    defaultStateValues = dropdownDefaultStateValues;\n  }\n\n  const defaultValue = props[`default${capitalizeString(propKey)}`];\n\n  if (defaultValue !== undefined) {\n    return defaultValue;\n  }\n\n  return defaultStateValues[propKey];\n}\n\nfunction getInitialValue$1(props, propKey, defaultStateValues) {\n  if (defaultStateValues === void 0) {\n    defaultStateValues = dropdownDefaultStateValues;\n  }\n\n  const value = props[propKey];\n\n  if (value !== undefined) {\n    return value;\n  }\n\n  const initialValue = props[`initial${capitalizeString(propKey)}`];\n\n  if (initialValue !== undefined) {\n    return initialValue;\n  }\n\n  return getDefaultValue$1(props, propKey, defaultStateValues);\n}\n\nfunction getInitialState$2(props) {\n  const selectedItem = getInitialValue$1(props, 'selectedItem');\n  const isOpen = getInitialValue$1(props, 'isOpen');\n  const highlightedIndex = getInitialValue$1(props, 'highlightedIndex');\n  const inputValue = getInitialValue$1(props, 'inputValue');\n  return {\n    highlightedIndex: highlightedIndex < 0 && selectedItem && isOpen ? props.items.indexOf(selectedItem) : highlightedIndex,\n    isOpen,\n    selectedItem,\n    inputValue\n  };\n}\n\nfunction getHighlightedIndexOnOpen(props, state, offset, getItemNodeFromIndex) {\n  const {\n    items,\n    initialHighlightedIndex,\n    defaultHighlightedIndex\n  } = props;\n  const {\n    selectedItem,\n    highlightedIndex\n  } = state;\n\n  if (items.length === 0) {\n    return -1;\n  } // initialHighlightedIndex will give value to highlightedIndex on initial state only.\n\n\n  if (initialHighlightedIndex !== undefined && highlightedIndex === initialHighlightedIndex) {\n    return initialHighlightedIndex;\n  }\n\n  if (defaultHighlightedIndex !== undefined) {\n    return defaultHighlightedIndex;\n  }\n\n  if (selectedItem) {\n    if (offset === 0) {\n      return items.indexOf(selectedItem);\n    }\n\n    return getNextWrappingIndex(offset, items.indexOf(selectedItem), items.length, getItemNodeFromIndex, false);\n  }\n\n  if (offset === 0) {\n    return -1;\n  }\n\n  return offset < 0 ? items.length - 1 : 0;\n}\n/**\n * Reuse the movement tracking of mouse and touch events.\n *\n * @param {boolean} isOpen Whether the dropdown is open or not.\n * @param {Array<Object>} downshiftElementRefs Downshift element refs to track movement (toggleButton, menu etc.)\n * @param {Object} environment Environment where component/hook exists.\n * @param {Function} handleBlur Handler on blur from mouse or touch.\n * @returns {Object} Ref containing whether mouseDown or touchMove event is happening\n */\n\n\nfunction useMouseAndTouchTracker(isOpen, downshiftElementRefs, environment, handleBlur) {\n  const mouseAndTouchTrackersRef = useRef({\n    isMouseDown: false,\n    isTouchMove: false\n  });\n  useEffect(() => {\n    // The same strategy for checking if a click occurred inside or outside downsift\n    // as in downshift.js.\n    const onMouseDown = () => {\n      mouseAndTouchTrackersRef.current.isMouseDown = true;\n    };\n\n    const onMouseUp = event => {\n      mouseAndTouchTrackersRef.current.isMouseDown = false;\n\n      if (isOpen && !targetWithinDownshift(event.target, downshiftElementRefs.map(ref => ref.current), environment)) {\n        handleBlur();\n      }\n    };\n\n    const onTouchStart = () => {\n      mouseAndTouchTrackersRef.current.isTouchMove = false;\n    };\n\n    const onTouchMove = () => {\n      mouseAndTouchTrackersRef.current.isTouchMove = true;\n    };\n\n    const onTouchEnd = event => {\n      if (isOpen && !mouseAndTouchTrackersRef.current.isTouchMove && !targetWithinDownshift(event.target, downshiftElementRefs.map(ref => ref.current), environment, false)) {\n        handleBlur();\n      }\n    };\n\n    environment.addEventListener('mousedown', onMouseDown);\n    environment.addEventListener('mouseup', onMouseUp);\n    environment.addEventListener('touchstart', onTouchStart);\n    environment.addEventListener('touchmove', onTouchMove);\n    environment.addEventListener('touchend', onTouchEnd);\n    return function cleanup() {\n      environment.removeEventListener('mousedown', onMouseDown);\n      environment.removeEventListener('mouseup', onMouseUp);\n      environment.removeEventListener('touchstart', onTouchStart);\n      environment.removeEventListener('touchmove', onTouchMove);\n      environment.removeEventListener('touchend', onTouchEnd);\n    }; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isOpen, environment]);\n  return mouseAndTouchTrackersRef;\n}\n/* istanbul ignore next */\n// eslint-disable-next-line import/no-mutable-exports\n\n\nlet useGetterPropsCalledChecker = () => noop;\n/**\n * Custom hook that checks if getter props are called correctly.\n *\n * @param  {...any} propKeys Getter prop names to be handled.\n * @returns {Function} Setter function called inside getter props to set call information.\n */\n\n/* istanbul ignore next */\n\n\nif (process.env.NODE_ENV !== 'production') {\n  useGetterPropsCalledChecker = function () {\n    const isInitialMountRef = useRef(true);\n\n    for (var _len = arguments.length, propKeys = new Array(_len), _key = 0; _key < _len; _key++) {\n      propKeys[_key] = arguments[_key];\n    }\n\n    const getterPropsCalledRef = useRef(propKeys.reduce((acc, propKey) => {\n      acc[propKey] = {};\n      return acc;\n    }, {}));\n    useEffect(() => {\n      Object.keys(getterPropsCalledRef.current).forEach(propKey => {\n        const propCallInfo = getterPropsCalledRef.current[propKey];\n\n        if (isInitialMountRef.current) {\n          if (!Object.keys(propCallInfo).length) {\n            // eslint-disable-next-line no-console\n            console.error(`downshift: You forgot to call the ${propKey} getter function on your component / element.`);\n            return;\n          }\n        }\n\n        const {\n          suppressRefError,\n          refKey,\n          elementRef\n        } = propCallInfo;\n\n        if ((!elementRef || !elementRef.current) && !suppressRefError) {\n          // eslint-disable-next-line no-console\n          console.error(`downshift: The ref prop \"${refKey}\" from ${propKey} was not applied correctly on your element.`);\n        }\n      });\n      isInitialMountRef.current = false;\n    });\n    const setGetterPropCallInfo = useCallback((propKey, suppressRefError, refKey, elementRef) => {\n      getterPropsCalledRef.current[propKey] = {\n        suppressRefError,\n        refKey,\n        elementRef\n      };\n    }, []);\n    return setGetterPropCallInfo;\n  };\n}\n\nfunction useA11yMessageSetter(getA11yMessage, dependencyArray, _ref2) {\n  let {\n    isInitialMount,\n    highlightedIndex,\n    items,\n    environment,\n    ...rest\n  } = _ref2;\n  // Sets a11y status message on changes in state.\n  useEffect(() => {\n    if (isInitialMount || false) {\n      return;\n    }\n\n    updateA11yStatus(() => getA11yMessage({\n      highlightedIndex,\n      highlightedItem: items[highlightedIndex],\n      resultCount: items.length,\n      ...rest\n    }), environment.document); // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, dependencyArray);\n}\n\nfunction useScrollIntoView(_ref3) {\n  let {\n    highlightedIndex,\n    isOpen,\n    itemRefs,\n    getItemNodeFromIndex,\n    menuElement,\n    scrollIntoView: scrollIntoViewProp\n  } = _ref3;\n  // used not to scroll on highlight by mouse.\n  const shouldScrollRef = useRef(true); // Scroll on highlighted item if change comes from keyboard.\n\n  useIsomorphicLayoutEffect(() => {\n    if (highlightedIndex < 0 || !isOpen || !Object.keys(itemRefs.current).length) {\n      return;\n    }\n\n    if (shouldScrollRef.current === false) {\n      shouldScrollRef.current = true;\n    } else {\n      scrollIntoViewProp(getItemNodeFromIndex(highlightedIndex), menuElement);\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [highlightedIndex]);\n  return shouldScrollRef;\n} // eslint-disable-next-line import/no-mutable-exports\n\n\nlet useControlPropsValidator = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  useControlPropsValidator = _ref4 => {\n    let {\n      isInitialMount,\n      props,\n      state\n    } = _ref4;\n    // used for checking when props are moving from controlled to uncontrolled.\n    const prevPropsRef = useRef(props);\n    useEffect(() => {\n      if (isInitialMount) {\n        return;\n      }\n\n      validateControlledUnchanged(state, prevPropsRef.current, props);\n      prevPropsRef.current = props;\n    }, [state, props, isInitialMount]);\n  };\n}\n\n/* eslint-disable complexity */\n\nfunction downshiftCommonReducer(state, action, stateChangeTypes) {\n  const {\n    type,\n    props\n  } = action;\n  let changes;\n\n  switch (type) {\n    case stateChangeTypes.ItemMouseMove:\n      changes = {\n        highlightedIndex: action.disabled ? -1 : action.index\n      };\n      break;\n\n    case stateChangeTypes.MenuMouseLeave:\n      changes = {\n        highlightedIndex: -1\n      };\n      break;\n\n    case stateChangeTypes.ToggleButtonClick:\n    case stateChangeTypes.FunctionToggleMenu:\n      changes = {\n        isOpen: !state.isOpen,\n        highlightedIndex: state.isOpen ? -1 : getHighlightedIndexOnOpen(props, state, 0)\n      };\n      break;\n\n    case stateChangeTypes.FunctionOpenMenu:\n      changes = {\n        isOpen: true,\n        highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)\n      };\n      break;\n\n    case stateChangeTypes.FunctionCloseMenu:\n      changes = {\n        isOpen: false\n      };\n      break;\n\n    case stateChangeTypes.FunctionSetHighlightedIndex:\n      changes = {\n        highlightedIndex: action.highlightedIndex\n      };\n      break;\n\n    case stateChangeTypes.FunctionSetInputValue:\n      changes = {\n        inputValue: action.inputValue\n      };\n      break;\n\n    case stateChangeTypes.FunctionReset:\n      changes = {\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        selectedItem: getDefaultValue$1(props, 'selectedItem'),\n        inputValue: getDefaultValue$1(props, 'inputValue')\n      };\n      break;\n\n    default:\n      throw new Error('Reducer called without proper action type.');\n  }\n\n  return { ...state,\n    ...changes\n  };\n}\n/* eslint-enable complexity */\n\nfunction getItemIndexByCharacterKey(_a) {\n    var keysSoFar = _a.keysSoFar, highlightedIndex = _a.highlightedIndex, items = _a.items, itemToString = _a.itemToString, getItemNodeFromIndex = _a.getItemNodeFromIndex;\n    var lowerCasedKeysSoFar = keysSoFar.toLowerCase();\n    for (var index = 0; index < items.length; index++) {\n        var offsetIndex = (index + highlightedIndex + 1) % items.length;\n        var item = items[offsetIndex];\n        if (item !== undefined &&\n            itemToString(item)\n                .toLowerCase()\n                .startsWith(lowerCasedKeysSoFar)) {\n            var element = getItemNodeFromIndex(offsetIndex);\n            if (!(element === null || element === void 0 ? void 0 : element.hasAttribute('disabled'))) {\n                return offsetIndex;\n            }\n        }\n    }\n    return highlightedIndex;\n}\nvar propTypes$2 = {\n    items: PropTypes.array.isRequired,\n    itemToString: PropTypes.func,\n    getA11yStatusMessage: PropTypes.func,\n    getA11ySelectionMessage: PropTypes.func,\n    circularNavigation: PropTypes.bool,\n    highlightedIndex: PropTypes.number,\n    defaultHighlightedIndex: PropTypes.number,\n    initialHighlightedIndex: PropTypes.number,\n    isOpen: PropTypes.bool,\n    defaultIsOpen: PropTypes.bool,\n    initialIsOpen: PropTypes.bool,\n    selectedItem: PropTypes.any,\n    initialSelectedItem: PropTypes.any,\n    defaultSelectedItem: PropTypes.any,\n    id: PropTypes.string,\n    labelId: PropTypes.string,\n    menuId: PropTypes.string,\n    getItemId: PropTypes.func,\n    toggleButtonId: PropTypes.string,\n    stateReducer: PropTypes.func,\n    onSelectedItemChange: PropTypes.func,\n    onHighlightedIndexChange: PropTypes.func,\n    onStateChange: PropTypes.func,\n    onIsOpenChange: PropTypes.func,\n    environment: PropTypes.shape({\n        addEventListener: PropTypes.func,\n        removeEventListener: PropTypes.func,\n        document: PropTypes.shape({\n            getElementById: PropTypes.func,\n            activeElement: PropTypes.any,\n            body: PropTypes.any\n        })\n    })\n};\n/**\n * Default implementation for status message. Only added when menu is open.\n * Will specift if there are results in the list, and if so, how many,\n * and what keys are relevant.\n *\n * @param {Object} param the downshift state and other relevant properties\n * @return {String} the a11y status message\n */\nfunction getA11yStatusMessage(_a) {\n    var isOpen = _a.isOpen, resultCount = _a.resultCount, previousResultCount = _a.previousResultCount;\n    if (!isOpen) {\n        return '';\n    }\n    if (!resultCount) {\n        return 'No results are available.';\n    }\n    if (resultCount !== previousResultCount) {\n        return \"\".concat(resultCount, \" result\").concat(resultCount === 1 ? ' is' : 's are', \" available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select.\");\n    }\n    return '';\n}\nvar defaultProps$2 = __assign(__assign({}, defaultProps$3), { getA11yStatusMessage: getA11yStatusMessage });\n// eslint-disable-next-line import/no-mutable-exports\nvar validatePropTypes$2 = noop;\n/* istanbul ignore next */\nif (process.env.NODE_ENV !== 'production') {\n    validatePropTypes$2 = function (options, caller) {\n        PropTypes.checkPropTypes(propTypes$2, options, 'prop', caller.name);\n    };\n}\n\nconst MenuKeyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_arrow_down__' : 0;\nconst MenuKeyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_arrow_up__' : 1;\nconst MenuKeyDownEscape = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_escape__' : 2;\nconst MenuKeyDownHome = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_home__' : 3;\nconst MenuKeyDownEnd = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_end__' : 4;\nconst MenuKeyDownEnter = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_enter__' : 5;\nconst MenuKeyDownSpaceButton = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_space_button__' : 6;\nconst MenuKeyDownCharacter = process.env.NODE_ENV !== \"production\" ? '__menu_keydown_character__' : 7;\nconst MenuBlur = process.env.NODE_ENV !== \"production\" ? '__menu_blur__' : 8;\nconst MenuMouseLeave$1 = process.env.NODE_ENV !== \"production\" ? '__menu_mouse_leave__' : 9;\nconst ItemMouseMove$1 = process.env.NODE_ENV !== \"production\" ? '__item_mouse_move__' : 10;\nconst ItemClick$1 = process.env.NODE_ENV !== \"production\" ? '__item_click__' : 11;\nconst ToggleButtonClick$1 = process.env.NODE_ENV !== \"production\" ? '__togglebutton_click__' : 12;\nconst ToggleButtonKeyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__togglebutton_keydown_arrow_down__' : 13;\nconst ToggleButtonKeyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__togglebutton_keydown_arrow_up__' : 14;\nconst ToggleButtonKeyDownCharacter = process.env.NODE_ENV !== \"production\" ? '__togglebutton_keydown_character__' : 15;\nconst FunctionToggleMenu$1 = process.env.NODE_ENV !== \"production\" ? '__function_toggle_menu__' : 16;\nconst FunctionOpenMenu$1 = process.env.NODE_ENV !== \"production\" ? '__function_open_menu__' : 17;\nconst FunctionCloseMenu$1 = process.env.NODE_ENV !== \"production\" ? '__function_close_menu__' : 18;\nconst FunctionSetHighlightedIndex$1 = process.env.NODE_ENV !== \"production\" ? '__function_set_highlighted_index__' : 19;\nconst FunctionSelectItem$1 = process.env.NODE_ENV !== \"production\" ? '__function_select_item__' : 20;\nconst FunctionSetInputValue$1 = process.env.NODE_ENV !== \"production\" ? '__function_set_input_value__' : 21;\nconst FunctionReset$2 = process.env.NODE_ENV !== \"production\" ? '__function_reset__' : 22;\n\nvar stateChangeTypes$2 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  MenuKeyDownArrowDown: MenuKeyDownArrowDown,\n  MenuKeyDownArrowUp: MenuKeyDownArrowUp,\n  MenuKeyDownEscape: MenuKeyDownEscape,\n  MenuKeyDownHome: MenuKeyDownHome,\n  MenuKeyDownEnd: MenuKeyDownEnd,\n  MenuKeyDownEnter: MenuKeyDownEnter,\n  MenuKeyDownSpaceButton: MenuKeyDownSpaceButton,\n  MenuKeyDownCharacter: MenuKeyDownCharacter,\n  MenuBlur: MenuBlur,\n  MenuMouseLeave: MenuMouseLeave$1,\n  ItemMouseMove: ItemMouseMove$1,\n  ItemClick: ItemClick$1,\n  ToggleButtonClick: ToggleButtonClick$1,\n  ToggleButtonKeyDownArrowDown: ToggleButtonKeyDownArrowDown,\n  ToggleButtonKeyDownArrowUp: ToggleButtonKeyDownArrowUp,\n  ToggleButtonKeyDownCharacter: ToggleButtonKeyDownCharacter,\n  FunctionToggleMenu: FunctionToggleMenu$1,\n  FunctionOpenMenu: FunctionOpenMenu$1,\n  FunctionCloseMenu: FunctionCloseMenu$1,\n  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex$1,\n  FunctionSelectItem: FunctionSelectItem$1,\n  FunctionSetInputValue: FunctionSetInputValue$1,\n  FunctionReset: FunctionReset$2\n});\n\n/* eslint-disable complexity */\n\nfunction downshiftSelectReducer(state, action) {\n  const {\n    type,\n    props,\n    shiftKey\n  } = action;\n  let changes;\n\n  switch (type) {\n    case ItemClick$1:\n      changes = {\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        selectedItem: props.items[action.index]\n      };\n      break;\n\n    case ToggleButtonKeyDownCharacter:\n      {\n        const lowercasedKey = action.key;\n        const inputValue = `${state.inputValue}${lowercasedKey}`;\n        const itemIndex = getItemIndexByCharacterKey({\n          keysSoFar: inputValue,\n          highlightedIndex: state.selectedItem ? props.items.indexOf(state.selectedItem) : -1,\n          items: props.items,\n          itemToString: props.itemToString,\n          getItemNodeFromIndex: action.getItemNodeFromIndex\n        });\n        changes = {\n          inputValue,\n          ...(itemIndex >= 0 && {\n            selectedItem: props.items[itemIndex]\n          })\n        };\n      }\n      break;\n\n    case ToggleButtonKeyDownArrowDown:\n      changes = {\n        highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),\n        isOpen: true\n      };\n      break;\n\n    case ToggleButtonKeyDownArrowUp:\n      changes = {\n        highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),\n        isOpen: true\n      };\n      break;\n\n    case MenuKeyDownEnter:\n    case MenuKeyDownSpaceButton:\n      changes = {\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        ...(state.highlightedIndex >= 0 && {\n          selectedItem: props.items[state.highlightedIndex]\n        })\n      };\n      break;\n\n    case MenuKeyDownHome:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n\n    case MenuKeyDownEnd:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n\n    case MenuKeyDownEscape:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1\n      };\n      break;\n\n    case MenuBlur:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1\n      };\n      break;\n\n    case MenuKeyDownCharacter:\n      {\n        const lowercasedKey = action.key;\n        const inputValue = `${state.inputValue}${lowercasedKey}`;\n        const highlightedIndex = getItemIndexByCharacterKey({\n          keysSoFar: inputValue,\n          highlightedIndex: state.highlightedIndex,\n          items: props.items,\n          itemToString: props.itemToString,\n          getItemNodeFromIndex: action.getItemNodeFromIndex\n        });\n        changes = {\n          inputValue,\n          ...(highlightedIndex >= 0 && {\n            highlightedIndex\n          })\n        };\n      }\n      break;\n\n    case MenuKeyDownArrowDown:\n      changes = {\n        highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n      };\n      break;\n\n    case MenuKeyDownArrowUp:\n      changes = {\n        highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n      };\n      break;\n\n    case FunctionSelectItem$1:\n      changes = {\n        selectedItem: action.selectedItem\n      };\n      break;\n\n    default:\n      return downshiftCommonReducer(state, action, stateChangeTypes$2);\n  }\n\n  return { ...state,\n    ...changes\n  };\n}\n/* eslint-enable complexity */\n\n/* eslint-disable max-statements */\nuseSelect.stateChangeTypes = stateChangeTypes$2;\n\nfunction useSelect(userProps) {\n  if (userProps === void 0) {\n    userProps = {};\n  }\n\n  validatePropTypes$2(userProps, useSelect); // Props defaults and destructuring.\n\n  const props = { ...defaultProps$2,\n    ...userProps\n  };\n  const {\n    items,\n    scrollIntoView,\n    environment,\n    initialIsOpen,\n    defaultIsOpen,\n    itemToString,\n    getA11ySelectionMessage,\n    getA11yStatusMessage\n  } = props; // Initial state depending on controlled props.\n\n  const initialState = getInitialState$2(props);\n  const [state, dispatch] = useControlledReducer$1(downshiftSelectReducer, initialState, props);\n  const {\n    isOpen,\n    highlightedIndex,\n    selectedItem,\n    inputValue\n  } = state; // Element efs.\n\n  const toggleButtonRef = useRef(null);\n  const menuRef = useRef(null);\n  const itemRefs = useRef({}); // used not to trigger menu blur action in some scenarios.\n\n  const shouldBlurRef = useRef(true); // used to keep the inputValue clearTimeout object between renders.\n\n  const clearTimeoutRef = useRef(null); // prevent id re-generation between renders.\n\n  const elementIds = useElementIds(props); // used to keep track of how many items we had on previous cycle.\n\n  const previousResultCountRef = useRef();\n  const isInitialMountRef = useRef(true); // utility callback to get item element.\n\n  const latest = useLatestRef({\n    state,\n    props\n  }); // Some utils.\n\n  const getItemNodeFromIndex = useCallback(index => itemRefs.current[elementIds.getItemId(index)], [elementIds]); // Effects.\n  // Sets a11y status message on changes in state.\n\n  useA11yMessageSetter(getA11yStatusMessage, [isOpen, highlightedIndex, inputValue, items], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Sets a11y status message on changes in selectedItem.\n\n  useA11yMessageSetter(getA11ySelectionMessage, [selectedItem], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Scroll on highlighted item if change comes from keyboard.\n\n  const shouldScrollRef = useScrollIntoView({\n    menuElement: menuRef.current,\n    highlightedIndex,\n    isOpen,\n    itemRefs,\n    scrollIntoView,\n    getItemNodeFromIndex\n  }); // Sets cleanup for the keysSoFar callback, debounded after 500ms.\n\n  useEffect(() => {\n    // init the clean function here as we need access to dispatch.\n    clearTimeoutRef.current = debounce(outerDispatch => {\n      outerDispatch({\n        type: FunctionSetInputValue$1,\n        inputValue: ''\n      });\n    }, 500); // Cancel any pending debounced calls on mount\n\n    return () => {\n      clearTimeoutRef.current.cancel();\n    };\n  }, []); // Invokes the keysSoFar callback set up above.\n\n  useEffect(() => {\n    if (!inputValue) {\n      return;\n    }\n\n    clearTimeoutRef.current(dispatch);\n  }, [dispatch, inputValue]);\n  useControlPropsValidator({\n    isInitialMount: isInitialMountRef.current,\n    props,\n    state\n  });\n  /* Controls the focus on the menu or the toggle button. */\n\n  useEffect(() => {\n    // Don't focus menu on first render.\n    if (isInitialMountRef.current) {\n      // Unless it was initialised as open.\n      if ((initialIsOpen || defaultIsOpen || isOpen) && menuRef.current) {\n        menuRef.current.focus();\n      }\n\n      return;\n    } // Focus menu on open.\n\n\n    if (isOpen) {\n      // istanbul ignore else\n      if (menuRef.current) {\n        menuRef.current.focus();\n      }\n\n      return;\n    } // Focus toggleButton on close, but not if it was closed with (Shift+)Tab.\n\n\n    if (environment.document.activeElement === menuRef.current) {\n      // istanbul ignore else\n      if (toggleButtonRef.current) {\n        shouldBlurRef.current = false;\n        toggleButtonRef.current.focus();\n      }\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, [isOpen]);\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n\n    previousResultCountRef.current = items.length;\n  }); // Add mouse/touch events to document.\n\n  const mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [menuRef, toggleButtonRef], environment, () => {\n    dispatch({\n      type: MenuBlur\n    });\n  });\n  const setGetterPropCallInfo = useGetterPropsCalledChecker('getMenuProps', 'getToggleButtonProps'); // Make initial ref false.\n\n  useEffect(() => {\n    isInitialMountRef.current = false;\n  }, []); // Reset itemRefs on close.\n\n  useEffect(() => {\n    if (!isOpen) {\n      itemRefs.current = {};\n    }\n  }, [isOpen]); // Event handler functions.\n\n  const toggleButtonKeyDownHandlers = useMemo(() => ({\n    ArrowDown(event) {\n      event.preventDefault();\n      dispatch({\n        type: ToggleButtonKeyDownArrowDown,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    },\n\n    ArrowUp(event) {\n      event.preventDefault();\n      dispatch({\n        type: ToggleButtonKeyDownArrowUp,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    }\n\n  }), [dispatch, getItemNodeFromIndex]);\n  const menuKeyDownHandlers = useMemo(() => ({\n    ArrowDown(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownArrowDown,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    },\n\n    ArrowUp(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownArrowUp,\n        getItemNodeFromIndex,\n        shiftKey: event.shiftKey\n      });\n    },\n\n    Home(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownHome,\n        getItemNodeFromIndex\n      });\n    },\n\n    End(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownEnd,\n        getItemNodeFromIndex\n      });\n    },\n\n    Escape() {\n      dispatch({\n        type: MenuKeyDownEscape\n      });\n    },\n\n    Enter(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownEnter\n      });\n    },\n\n    ' '(event) {\n      event.preventDefault();\n      dispatch({\n        type: MenuKeyDownSpaceButton\n      });\n    }\n\n  }), [dispatch, getItemNodeFromIndex]); // Action functions.\n\n  const toggleMenu = useCallback(() => {\n    dispatch({\n      type: FunctionToggleMenu$1\n    });\n  }, [dispatch]);\n  const closeMenu = useCallback(() => {\n    dispatch({\n      type: FunctionCloseMenu$1\n    });\n  }, [dispatch]);\n  const openMenu = useCallback(() => {\n    dispatch({\n      type: FunctionOpenMenu$1\n    });\n  }, [dispatch]);\n  const setHighlightedIndex = useCallback(newHighlightedIndex => {\n    dispatch({\n      type: FunctionSetHighlightedIndex$1,\n      highlightedIndex: newHighlightedIndex\n    });\n  }, [dispatch]);\n  const selectItem = useCallback(newSelectedItem => {\n    dispatch({\n      type: FunctionSelectItem$1,\n      selectedItem: newSelectedItem\n    });\n  }, [dispatch]);\n  const reset = useCallback(() => {\n    dispatch({\n      type: FunctionReset$2\n    });\n  }, [dispatch]);\n  const setInputValue = useCallback(newInputValue => {\n    dispatch({\n      type: FunctionSetInputValue$1,\n      inputValue: newInputValue\n    });\n  }, [dispatch]); // Getter functions.\n\n  const getLabelProps = useCallback(labelProps => ({\n    id: elementIds.labelId,\n    htmlFor: elementIds.toggleButtonId,\n    ...labelProps\n  }), [elementIds]);\n  const getMenuProps = useCallback(function (_temp, _temp2) {\n    let {\n      onMouseLeave,\n      refKey = 'ref',\n      onKeyDown,\n      onBlur,\n      ref,\n      ...rest\n    } = _temp === void 0 ? {} : _temp;\n    let {\n      suppressRefError = false\n    } = _temp2 === void 0 ? {} : _temp2;\n    const latestState = latest.current.state;\n\n    const menuHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && menuKeyDownHandlers[key]) {\n        menuKeyDownHandlers[key](event);\n      } else if (isAcceptedCharacterKey(key)) {\n        dispatch({\n          type: MenuKeyDownCharacter,\n          key,\n          getItemNodeFromIndex\n        });\n      }\n    };\n\n    const menuHandleBlur = () => {\n      // if the blur was a result of selection, we don't trigger this action.\n      if (shouldBlurRef.current === false) {\n        shouldBlurRef.current = true;\n        return;\n      }\n\n      const shouldBlur = !mouseAndTouchTrackersRef.current.isMouseDown;\n      /* istanbul ignore else */\n\n      if (shouldBlur) {\n        dispatch({\n          type: MenuBlur\n        });\n      }\n    };\n\n    const menuHandleMouseLeave = () => {\n      dispatch({\n        type: MenuMouseLeave$1\n      });\n    };\n\n    setGetterPropCallInfo('getMenuProps', suppressRefError, refKey, menuRef);\n    return {\n      [refKey]: handleRefs(ref, menuNode => {\n        menuRef.current = menuNode;\n      }),\n      id: elementIds.menuId,\n      role: 'listbox',\n      'aria-labelledby': elementIds.labelId,\n      tabIndex: -1,\n      ...(latestState.isOpen && latestState.highlightedIndex > -1 && {\n        'aria-activedescendant': elementIds.getItemId(latestState.highlightedIndex)\n      }),\n      onMouseLeave: callAllEventHandlers(onMouseLeave, menuHandleMouseLeave),\n      onKeyDown: callAllEventHandlers(onKeyDown, menuHandleKeyDown),\n      onBlur: callAllEventHandlers(onBlur, menuHandleBlur),\n      ...rest\n    };\n  }, [dispatch, latest, menuKeyDownHandlers, mouseAndTouchTrackersRef, setGetterPropCallInfo, elementIds, getItemNodeFromIndex]);\n  const getToggleButtonProps = useCallback(function (_temp3, _temp4) {\n    let {\n      onClick,\n      onKeyDown,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp3 === void 0 ? {} : _temp3;\n    let {\n      suppressRefError = false\n    } = _temp4 === void 0 ? {} : _temp4;\n\n    const toggleButtonHandleClick = () => {\n      dispatch({\n        type: ToggleButtonClick$1\n      });\n    };\n\n    const toggleButtonHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && toggleButtonKeyDownHandlers[key]) {\n        toggleButtonKeyDownHandlers[key](event);\n      } else if (isAcceptedCharacterKey(key)) {\n        dispatch({\n          type: ToggleButtonKeyDownCharacter,\n          key,\n          getItemNodeFromIndex\n        });\n      }\n    };\n\n    const toggleProps = {\n      [refKey]: handleRefs(ref, toggleButtonNode => {\n        toggleButtonRef.current = toggleButtonNode;\n      }),\n      id: elementIds.toggleButtonId,\n      'aria-haspopup': 'listbox',\n      'aria-expanded': latest.current.state.isOpen,\n      'aria-labelledby': `${elementIds.labelId} ${elementIds.toggleButtonId}`,\n      ...rest\n    };\n\n    if (!rest.disabled) {\n      toggleProps.onClick = callAllEventHandlers(onClick, toggleButtonHandleClick);\n      toggleProps.onKeyDown = callAllEventHandlers(onKeyDown, toggleButtonHandleKeyDown);\n    }\n\n    setGetterPropCallInfo('getToggleButtonProps', suppressRefError, refKey, toggleButtonRef);\n    return toggleProps;\n  }, [dispatch, latest, toggleButtonKeyDownHandlers, setGetterPropCallInfo, elementIds, getItemNodeFromIndex]);\n  const getItemProps = useCallback(function (_temp5) {\n    let {\n      item,\n      index,\n      onMouseMove,\n      onClick,\n      refKey = 'ref',\n      ref,\n      disabled,\n      ...rest\n    } = _temp5 === void 0 ? {} : _temp5;\n    const {\n      state: latestState,\n      props: latestProps\n    } = latest.current;\n\n    const itemHandleMouseMove = () => {\n      if (index === latestState.highlightedIndex) {\n        return;\n      }\n\n      shouldScrollRef.current = false;\n      dispatch({\n        type: ItemMouseMove$1,\n        index,\n        disabled\n      });\n    };\n\n    const itemHandleClick = () => {\n      dispatch({\n        type: ItemClick$1,\n        index\n      });\n    };\n\n    const itemIndex = getItemIndex(index, item, latestProps.items);\n\n    if (itemIndex < 0) {\n      throw new Error('Pass either item or item index in getItemProps!');\n    }\n\n    const itemProps = {\n      disabled,\n      role: 'option',\n      'aria-selected': `${itemIndex === latestState.highlightedIndex}`,\n      id: elementIds.getItemId(itemIndex),\n      [refKey]: handleRefs(ref, itemNode => {\n        if (itemNode) {\n          itemRefs.current[elementIds.getItemId(itemIndex)] = itemNode;\n        }\n      }),\n      ...rest\n    };\n\n    if (!disabled) {\n      itemProps.onClick = callAllEventHandlers(onClick, itemHandleClick);\n    }\n\n    itemProps.onMouseMove = callAllEventHandlers(onMouseMove, itemHandleMouseMove);\n    return itemProps;\n  }, [dispatch, latest, shouldScrollRef, elementIds]);\n  return {\n    // prop getters.\n    getToggleButtonProps,\n    getLabelProps,\n    getMenuProps,\n    getItemProps,\n    // actions.\n    toggleMenu,\n    openMenu,\n    closeMenu,\n    setHighlightedIndex,\n    selectItem,\n    reset,\n    setInputValue,\n    // state.\n    highlightedIndex,\n    isOpen,\n    selectedItem,\n    inputValue\n  };\n}\n\nconst InputKeyDownArrowDown = process.env.NODE_ENV !== \"production\" ? '__input_keydown_arrow_down__' : 0;\nconst InputKeyDownArrowUp = process.env.NODE_ENV !== \"production\" ? '__input_keydown_arrow_up__' : 1;\nconst InputKeyDownEscape = process.env.NODE_ENV !== \"production\" ? '__input_keydown_escape__' : 2;\nconst InputKeyDownHome = process.env.NODE_ENV !== \"production\" ? '__input_keydown_home__' : 3;\nconst InputKeyDownEnd = process.env.NODE_ENV !== \"production\" ? '__input_keydown_end__' : 4;\nconst InputKeyDownEnter = process.env.NODE_ENV !== \"production\" ? '__input_keydown_enter__' : 5;\nconst InputChange = process.env.NODE_ENV !== \"production\" ? '__input_change__' : 6;\nconst InputBlur = process.env.NODE_ENV !== \"production\" ? '__input_blur__' : 7;\nconst MenuMouseLeave = process.env.NODE_ENV !== \"production\" ? '__menu_mouse_leave__' : 8;\nconst ItemMouseMove = process.env.NODE_ENV !== \"production\" ? '__item_mouse_move__' : 9;\nconst ItemClick = process.env.NODE_ENV !== \"production\" ? '__item_click__' : 10;\nconst ToggleButtonClick = process.env.NODE_ENV !== \"production\" ? '__togglebutton_click__' : 11;\nconst FunctionToggleMenu = process.env.NODE_ENV !== \"production\" ? '__function_toggle_menu__' : 12;\nconst FunctionOpenMenu = process.env.NODE_ENV !== \"production\" ? '__function_open_menu__' : 13;\nconst FunctionCloseMenu = process.env.NODE_ENV !== \"production\" ? '__function_close_menu__' : 14;\nconst FunctionSetHighlightedIndex = process.env.NODE_ENV !== \"production\" ? '__function_set_highlighted_index__' : 15;\nconst FunctionSelectItem = process.env.NODE_ENV !== \"production\" ? '__function_select_item__' : 16;\nconst FunctionSetInputValue = process.env.NODE_ENV !== \"production\" ? '__function_set_input_value__' : 17;\nconst FunctionReset$1 = process.env.NODE_ENV !== \"production\" ? '__function_reset__' : 18;\nconst ControlledPropUpdatedSelectedItem = process.env.NODE_ENV !== \"production\" ? '__controlled_prop_updated_selected_item__' : 19;\n\nvar stateChangeTypes$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  InputKeyDownArrowDown: InputKeyDownArrowDown,\n  InputKeyDownArrowUp: InputKeyDownArrowUp,\n  InputKeyDownEscape: InputKeyDownEscape,\n  InputKeyDownHome: InputKeyDownHome,\n  InputKeyDownEnd: InputKeyDownEnd,\n  InputKeyDownEnter: InputKeyDownEnter,\n  InputChange: InputChange,\n  InputBlur: InputBlur,\n  MenuMouseLeave: MenuMouseLeave,\n  ItemMouseMove: ItemMouseMove,\n  ItemClick: ItemClick,\n  ToggleButtonClick: ToggleButtonClick,\n  FunctionToggleMenu: FunctionToggleMenu,\n  FunctionOpenMenu: FunctionOpenMenu,\n  FunctionCloseMenu: FunctionCloseMenu,\n  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex,\n  FunctionSelectItem: FunctionSelectItem,\n  FunctionSetInputValue: FunctionSetInputValue,\n  FunctionReset: FunctionReset$1,\n  ControlledPropUpdatedSelectedItem: ControlledPropUpdatedSelectedItem\n});\n\nfunction getInitialState$1(props) {\n  const initialState = getInitialState$2(props);\n  const {\n    selectedItem\n  } = initialState;\n  let {\n    inputValue\n  } = initialState;\n\n  if (inputValue === '' && selectedItem && props.defaultInputValue === undefined && props.initialInputValue === undefined && props.inputValue === undefined) {\n    inputValue = props.itemToString(selectedItem);\n  }\n\n  return { ...initialState,\n    inputValue\n  };\n}\n\nconst propTypes$1 = {\n  items: PropTypes.array.isRequired,\n  itemToString: PropTypes.func,\n  getA11yStatusMessage: PropTypes.func,\n  getA11ySelectionMessage: PropTypes.func,\n  circularNavigation: PropTypes.bool,\n  highlightedIndex: PropTypes.number,\n  defaultHighlightedIndex: PropTypes.number,\n  initialHighlightedIndex: PropTypes.number,\n  isOpen: PropTypes.bool,\n  defaultIsOpen: PropTypes.bool,\n  initialIsOpen: PropTypes.bool,\n  selectedItem: PropTypes.any,\n  initialSelectedItem: PropTypes.any,\n  defaultSelectedItem: PropTypes.any,\n  inputValue: PropTypes.string,\n  defaultInputValue: PropTypes.string,\n  initialInputValue: PropTypes.string,\n  id: PropTypes.string,\n  labelId: PropTypes.string,\n  menuId: PropTypes.string,\n  getItemId: PropTypes.func,\n  inputId: PropTypes.string,\n  toggleButtonId: PropTypes.string,\n  stateReducer: PropTypes.func,\n  onSelectedItemChange: PropTypes.func,\n  onHighlightedIndexChange: PropTypes.func,\n  onStateChange: PropTypes.func,\n  onIsOpenChange: PropTypes.func,\n  onInputValueChange: PropTypes.func,\n  environment: PropTypes.shape({\n    addEventListener: PropTypes.func,\n    removeEventListener: PropTypes.func,\n    document: PropTypes.shape({\n      getElementById: PropTypes.func,\n      activeElement: PropTypes.any,\n      body: PropTypes.any\n    })\n  })\n};\n/**\n * The useCombobox version of useControlledReducer, which also\n * checks if the controlled prop selectedItem changed between\n * renders. If so, it will also update inputValue with its\n * string equivalent. It uses the common useEnhancedReducer to\n * compute the rest of the state.\n *\n * @param {Function} reducer Reducer function from downshift.\n * @param {Object} initialState Initial state of the hook.\n * @param {Object} props The hook props.\n * @returns {Array} An array with the state and an action dispatcher.\n */\n\nfunction useControlledReducer(reducer, initialState, props) {\n  const previousSelectedItemRef = useRef();\n  const [state, dispatch] = useEnhancedReducer(reducer, initialState, props); // ToDo: if needed, make same approach as selectedItemChanged from Downshift.\n\n  useEffect(() => {\n    if (isControlledProp(props, 'selectedItem')) {\n      if (previousSelectedItemRef.current !== props.selectedItem) {\n        dispatch({\n          type: ControlledPropUpdatedSelectedItem,\n          inputValue: props.itemToString(props.selectedItem)\n        });\n      }\n\n      previousSelectedItemRef.current = state.selectedItem === previousSelectedItemRef.current ? props.selectedItem : state.selectedItem;\n    }\n  });\n  return [getState(state, props), dispatch];\n} // eslint-disable-next-line import/no-mutable-exports\n\n\nlet validatePropTypes$1 = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  validatePropTypes$1 = (options, caller) => {\n    PropTypes.checkPropTypes(propTypes$1, options, 'prop', caller.name);\n  };\n}\n\nconst defaultProps$1 = { ...defaultProps$3,\n  getA11yStatusMessage: getA11yStatusMessage$1,\n  circularNavigation: true\n};\n\n/* eslint-disable complexity */\n\nfunction downshiftUseComboboxReducer(state, action) {\n  const {\n    type,\n    props,\n    shiftKey\n  } = action;\n  let changes;\n\n  switch (type) {\n    case ItemClick:\n      changes = {\n        isOpen: getDefaultValue$1(props, 'isOpen'),\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        selectedItem: props.items[action.index],\n        inputValue: props.itemToString(props.items[action.index])\n      };\n      break;\n\n    case InputKeyDownArrowDown:\n      if (state.isOpen) {\n        changes = {\n          highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n        };\n      } else {\n        changes = {\n          highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),\n          isOpen: props.items.length >= 0\n        };\n      }\n\n      break;\n\n    case InputKeyDownArrowUp:\n      if (state.isOpen) {\n        changes = {\n          highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)\n        };\n      } else {\n        changes = {\n          highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),\n          isOpen: props.items.length >= 0\n        };\n      }\n\n      break;\n\n    case InputKeyDownEnter:\n      changes = { ...(state.isOpen && state.highlightedIndex >= 0 && {\n          selectedItem: props.items[state.highlightedIndex],\n          isOpen: getDefaultValue$1(props, 'isOpen'),\n          highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n          inputValue: props.itemToString(props.items[state.highlightedIndex])\n        })\n      };\n      break;\n\n    case InputKeyDownEscape:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1,\n        ...(!state.isOpen && {\n          selectedItem: null,\n          inputValue: ''\n        })\n      };\n      break;\n\n    case InputKeyDownHome:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n\n    case InputKeyDownEnd:\n      changes = {\n        highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)\n      };\n      break;\n\n    case InputBlur:\n      changes = {\n        isOpen: false,\n        highlightedIndex: -1,\n        ...(state.highlightedIndex >= 0 && action.selectItem && {\n          selectedItem: props.items[state.highlightedIndex],\n          inputValue: props.itemToString(props.items[state.highlightedIndex])\n        })\n      };\n      break;\n\n    case InputChange:\n      changes = {\n        isOpen: true,\n        highlightedIndex: getDefaultValue$1(props, 'highlightedIndex'),\n        inputValue: action.inputValue\n      };\n      break;\n\n    case FunctionSelectItem:\n      changes = {\n        selectedItem: action.selectedItem,\n        inputValue: props.itemToString(action.selectedItem)\n      };\n      break;\n\n    case ControlledPropUpdatedSelectedItem:\n      changes = {\n        inputValue: action.inputValue\n      };\n      break;\n\n    default:\n      return downshiftCommonReducer(state, action, stateChangeTypes$1);\n  }\n\n  return { ...state,\n    ...changes\n  };\n}\n/* eslint-enable complexity */\n\n/* eslint-disable max-statements */\nuseCombobox.stateChangeTypes = stateChangeTypes$1;\n\nfunction useCombobox(userProps) {\n  if (userProps === void 0) {\n    userProps = {};\n  }\n\n  validatePropTypes$1(userProps, useCombobox); // Props defaults and destructuring.\n\n  const props = { ...defaultProps$1,\n    ...userProps\n  };\n  const {\n    initialIsOpen,\n    defaultIsOpen,\n    items,\n    scrollIntoView,\n    environment,\n    getA11yStatusMessage,\n    getA11ySelectionMessage,\n    itemToString\n  } = props; // Initial state depending on controlled props.\n\n  const initialState = getInitialState$1(props);\n  const [state, dispatch] = useControlledReducer(downshiftUseComboboxReducer, initialState, props);\n  const {\n    isOpen,\n    highlightedIndex,\n    selectedItem,\n    inputValue\n  } = state; // Element refs.\n\n  const menuRef = useRef(null);\n  const itemRefs = useRef({});\n  const inputRef = useRef(null);\n  const toggleButtonRef = useRef(null);\n  const comboboxRef = useRef(null);\n  const isInitialMountRef = useRef(true); // prevent id re-generation between renders.\n\n  const elementIds = useElementIds(props); // used to keep track of how many items we had on previous cycle.\n\n  const previousResultCountRef = useRef(); // utility callback to get item element.\n\n  const latest = useLatestRef({\n    state,\n    props\n  });\n  const getItemNodeFromIndex = useCallback(index => itemRefs.current[elementIds.getItemId(index)], [elementIds]); // Effects.\n  // Sets a11y status message on changes in state.\n\n  useA11yMessageSetter(getA11yStatusMessage, [isOpen, highlightedIndex, inputValue, items], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Sets a11y status message on changes in selectedItem.\n\n  useA11yMessageSetter(getA11ySelectionMessage, [selectedItem], {\n    isInitialMount: isInitialMountRef.current,\n    previousResultCount: previousResultCountRef.current,\n    items,\n    environment,\n    itemToString,\n    ...state\n  }); // Scroll on highlighted item if change comes from keyboard.\n\n  const shouldScrollRef = useScrollIntoView({\n    menuElement: menuRef.current,\n    highlightedIndex,\n    isOpen,\n    itemRefs,\n    scrollIntoView,\n    getItemNodeFromIndex\n  });\n  useControlPropsValidator({\n    isInitialMount: isInitialMountRef.current,\n    props,\n    state\n  }); // Focus the input on first render if required.\n\n  useEffect(() => {\n    const focusOnOpen = initialIsOpen || defaultIsOpen || isOpen;\n\n    if (focusOnOpen && inputRef.current) {\n      inputRef.current.focus();\n    } // eslint-disable-next-line react-hooks/exhaustive-deps\n\n  }, []);\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n\n    previousResultCountRef.current = items.length;\n  }); // Add mouse/touch events to document.\n\n  const mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [comboboxRef, menuRef, toggleButtonRef], environment, () => {\n    dispatch({\n      type: InputBlur,\n      selectItem: false\n    });\n  });\n  const setGetterPropCallInfo = useGetterPropsCalledChecker('getInputProps', 'getComboboxProps', 'getMenuProps'); // Make initial ref false.\n\n  useEffect(() => {\n    isInitialMountRef.current = false;\n  }, []); // Reset itemRefs on close.\n\n  useEffect(() => {\n    if (!isOpen) {\n      itemRefs.current = {};\n    }\n  }, [isOpen]);\n  /* Event handler functions */\n\n  const inputKeyDownHandlers = useMemo(() => ({\n    ArrowDown(event) {\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownArrowDown,\n        shiftKey: event.shiftKey,\n        getItemNodeFromIndex\n      });\n    },\n\n    ArrowUp(event) {\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownArrowUp,\n        shiftKey: event.shiftKey,\n        getItemNodeFromIndex\n      });\n    },\n\n    Home(event) {\n      if (!latest.current.state.isOpen) {\n        return;\n      }\n\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownHome,\n        getItemNodeFromIndex\n      });\n    },\n\n    End(event) {\n      if (!latest.current.state.isOpen) {\n        return;\n      }\n\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownEnd,\n        getItemNodeFromIndex\n      });\n    },\n\n    Escape(event) {\n      const latestState = latest.current.state;\n\n      if (latestState.isOpen || latestState.inputValue || latestState.selectedItem || latestState.highlightedIndex > -1) {\n        event.preventDefault();\n        dispatch({\n          type: InputKeyDownEscape\n        });\n      }\n    },\n\n    Enter(event) {\n      const latestState = latest.current.state; // if closed or no highlighted index, do nothing.\n\n      if (!latestState.isOpen || latestState.highlightedIndex < 0 || event.which === 229 // if IME composing, wait for next Enter keydown event.\n      ) {\n        return;\n      }\n\n      event.preventDefault();\n      dispatch({\n        type: InputKeyDownEnter,\n        getItemNodeFromIndex\n      });\n    }\n\n  }), [dispatch, latest, getItemNodeFromIndex]); // Getter props.\n\n  const getLabelProps = useCallback(labelProps => ({\n    id: elementIds.labelId,\n    htmlFor: elementIds.inputId,\n    ...labelProps\n  }), [elementIds]);\n  const getMenuProps = useCallback(function (_temp, _temp2) {\n    let {\n      onMouseLeave,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp === void 0 ? {} : _temp;\n    let {\n      suppressRefError = false\n    } = _temp2 === void 0 ? {} : _temp2;\n    setGetterPropCallInfo('getMenuProps', suppressRefError, refKey, menuRef);\n    return {\n      [refKey]: handleRefs(ref, menuNode => {\n        menuRef.current = menuNode;\n      }),\n      id: elementIds.menuId,\n      role: 'listbox',\n      'aria-labelledby': elementIds.labelId,\n      onMouseLeave: callAllEventHandlers(onMouseLeave, () => {\n        dispatch({\n          type: MenuMouseLeave\n        });\n      }),\n      ...rest\n    };\n  }, [dispatch, setGetterPropCallInfo, elementIds]);\n  const getItemProps = useCallback(function (_temp3) {\n    let {\n      item,\n      index,\n      refKey = 'ref',\n      ref,\n      onMouseMove,\n      onMouseDown,\n      onClick,\n      onPress,\n      disabled,\n      ...rest\n    } = _temp3 === void 0 ? {} : _temp3;\n    const {\n      props: latestProps,\n      state: latestState\n    } = latest.current;\n    const itemIndex = getItemIndex(index, item, latestProps.items);\n\n    if (itemIndex < 0) {\n      throw new Error('Pass either item or item index in getItemProps!');\n    }\n\n    const onSelectKey = 'onClick';\n    const customClickHandler = onClick;\n\n    const itemHandleMouseMove = () => {\n      if (index === latestState.highlightedIndex) {\n        return;\n      }\n\n      shouldScrollRef.current = false;\n      dispatch({\n        type: ItemMouseMove,\n        index,\n        disabled\n      });\n    };\n\n    const itemHandleClick = () => {\n      dispatch({\n        type: ItemClick,\n        index\n      });\n    };\n\n    const itemHandleMouseDown = e => e.preventDefault();\n\n    return {\n      [refKey]: handleRefs(ref, itemNode => {\n        if (itemNode) {\n          itemRefs.current[elementIds.getItemId(itemIndex)] = itemNode;\n        }\n      }),\n      disabled,\n      role: 'option',\n      'aria-selected': `${itemIndex === latestState.highlightedIndex}`,\n      id: elementIds.getItemId(itemIndex),\n      ...(!disabled && {\n        [onSelectKey]: callAllEventHandlers(customClickHandler, itemHandleClick)\n      }),\n      onMouseMove: callAllEventHandlers(onMouseMove, itemHandleMouseMove),\n      onMouseDown: callAllEventHandlers(onMouseDown, itemHandleMouseDown),\n      ...rest\n    };\n  }, [dispatch, latest, shouldScrollRef, elementIds]);\n  const getToggleButtonProps = useCallback(function (_temp4) {\n    let {\n      onClick,\n      onPress,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp4 === void 0 ? {} : _temp4;\n\n    const toggleButtonHandleClick = () => {\n      dispatch({\n        type: ToggleButtonClick\n      });\n\n      if (!latest.current.state.isOpen && inputRef.current) {\n        inputRef.current.focus();\n      }\n    };\n\n    return {\n      [refKey]: handleRefs(ref, toggleButtonNode => {\n        toggleButtonRef.current = toggleButtonNode;\n      }),\n      id: elementIds.toggleButtonId,\n      tabIndex: -1,\n      ...(!rest.disabled && { ...({\n          onClick: callAllEventHandlers(onClick, toggleButtonHandleClick)\n        })\n      }),\n      ...rest\n    };\n  }, [dispatch, latest, elementIds]);\n  const getInputProps = useCallback(function (_temp5, _temp6) {\n    let {\n      onKeyDown,\n      onChange,\n      onInput,\n      onBlur,\n      onChangeText,\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp5 === void 0 ? {} : _temp5;\n    let {\n      suppressRefError = false\n    } = _temp6 === void 0 ? {} : _temp6;\n    setGetterPropCallInfo('getInputProps', suppressRefError, refKey, inputRef);\n    const latestState = latest.current.state;\n\n    const inputHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && inputKeyDownHandlers[key]) {\n        inputKeyDownHandlers[key](event);\n      }\n    };\n\n    const inputHandleChange = event => {\n      dispatch({\n        type: InputChange,\n        inputValue: event.target.value\n      });\n    };\n\n    const inputHandleBlur = () => {\n      /* istanbul ignore else */\n      if (latestState.isOpen && !mouseAndTouchTrackersRef.current.isMouseDown) {\n        dispatch({\n          type: InputBlur,\n          selectItem: true\n        });\n      }\n    };\n    /* istanbul ignore next (preact) */\n\n\n    const onChangeKey = 'onChange';\n    let eventHandlers = {};\n\n    if (!rest.disabled) {\n      eventHandlers = {\n        [onChangeKey]: callAllEventHandlers(onChange, onInput, inputHandleChange),\n        onKeyDown: callAllEventHandlers(onKeyDown, inputHandleKeyDown),\n        onBlur: callAllEventHandlers(onBlur, inputHandleBlur)\n      };\n    }\n\n    return {\n      [refKey]: handleRefs(ref, inputNode => {\n        inputRef.current = inputNode;\n      }),\n      id: elementIds.inputId,\n      'aria-autocomplete': 'list',\n      'aria-controls': elementIds.menuId,\n      ...(latestState.isOpen && latestState.highlightedIndex > -1 && {\n        'aria-activedescendant': elementIds.getItemId(latestState.highlightedIndex)\n      }),\n      'aria-labelledby': elementIds.labelId,\n      // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion\n      // revert back since autocomplete=\"nope\" is ignored on latest Chrome and Opera\n      autoComplete: 'off',\n      value: latestState.inputValue,\n      ...eventHandlers,\n      ...rest\n    };\n  }, [dispatch, inputKeyDownHandlers, latest, mouseAndTouchTrackersRef, setGetterPropCallInfo, elementIds]);\n  const getComboboxProps = useCallback(function (_temp7, _temp8) {\n    let {\n      refKey = 'ref',\n      ref,\n      ...rest\n    } = _temp7 === void 0 ? {} : _temp7;\n    let {\n      suppressRefError = false\n    } = _temp8 === void 0 ? {} : _temp8;\n    setGetterPropCallInfo('getComboboxProps', suppressRefError, refKey, comboboxRef);\n    return {\n      [refKey]: handleRefs(ref, comboboxNode => {\n        comboboxRef.current = comboboxNode;\n      }),\n      role: 'combobox',\n      'aria-haspopup': 'listbox',\n      'aria-owns': elementIds.menuId,\n      'aria-expanded': latest.current.state.isOpen,\n      ...rest\n    };\n  }, [latest, setGetterPropCallInfo, elementIds]); // returns\n\n  const toggleMenu = useCallback(() => {\n    dispatch({\n      type: FunctionToggleMenu\n    });\n  }, [dispatch]);\n  const closeMenu = useCallback(() => {\n    dispatch({\n      type: FunctionCloseMenu\n    });\n  }, [dispatch]);\n  const openMenu = useCallback(() => {\n    dispatch({\n      type: FunctionOpenMenu\n    });\n  }, [dispatch]);\n  const setHighlightedIndex = useCallback(newHighlightedIndex => {\n    dispatch({\n      type: FunctionSetHighlightedIndex,\n      highlightedIndex: newHighlightedIndex\n    });\n  }, [dispatch]);\n  const selectItem = useCallback(newSelectedItem => {\n    dispatch({\n      type: FunctionSelectItem,\n      selectedItem: newSelectedItem\n    });\n  }, [dispatch]);\n  const setInputValue = useCallback(newInputValue => {\n    dispatch({\n      type: FunctionSetInputValue,\n      inputValue: newInputValue\n    });\n  }, [dispatch]);\n  const reset = useCallback(() => {\n    dispatch({\n      type: FunctionReset$1\n    });\n  }, [dispatch]);\n  return {\n    // prop getters.\n    getItemProps,\n    getLabelProps,\n    getMenuProps,\n    getInputProps,\n    getComboboxProps,\n    getToggleButtonProps,\n    // actions.\n    toggleMenu,\n    openMenu,\n    closeMenu,\n    setHighlightedIndex,\n    setInputValue,\n    selectItem,\n    reset,\n    // state.\n    highlightedIndex,\n    isOpen,\n    selectedItem,\n    inputValue\n  };\n}\n\nconst defaultStateValues = {\n  activeIndex: -1,\n  selectedItems: []\n};\n/**\n * Returns the initial value for a state key in the following order:\n * 1. controlled prop, 2. initial prop, 3. default prop, 4. default\n * value from Downshift.\n *\n * @param {Object} props Props passed to the hook.\n * @param {string} propKey Props key to generate the value for.\n * @returns {any} The initial value for that prop.\n */\n\nfunction getInitialValue(props, propKey) {\n  return getInitialValue$1(props, propKey, defaultStateValues);\n}\n/**\n * Returns the default value for a state key in the following order:\n * 1. controlled prop, 2. default prop, 3. default value from Downshift.\n *\n * @param {Object} props Props passed to the hook.\n * @param {string} propKey Props key to generate the value for.\n * @returns {any} The initial value for that prop.\n */\n\n\nfunction getDefaultValue(props, propKey) {\n  return getDefaultValue$1(props, propKey, defaultStateValues);\n}\n/**\n * Gets the initial state based on the provided props. It uses initial, default\n * and controlled props related to state in order to compute the initial value.\n *\n * @param {Object} props Props passed to the hook.\n * @returns {Object} The initial state.\n */\n\n\nfunction getInitialState(props) {\n  const activeIndex = getInitialValue(props, 'activeIndex');\n  const selectedItems = getInitialValue(props, 'selectedItems');\n  return {\n    activeIndex,\n    selectedItems\n  };\n}\n/**\n * Returns true if dropdown keydown operation is permitted. Should not be\n * allowed on keydown with modifier keys (ctrl, alt, shift, meta), on\n * input element with text content that is either highlighted or selection\n * cursor is not at the starting position.\n *\n * @param {KeyboardEvent} event The event from keydown.\n * @returns {boolean} Whether the operation is allowed.\n */\n\n\nfunction isKeyDownOperationPermitted(event) {\n  if (event.shiftKey || event.metaKey || event.ctrlKey || event.altKey) {\n    return false;\n  }\n\n  const element = event.target;\n\n  if (element instanceof HTMLInputElement && // if element is a text input\n  element.value !== '' && ( // and we have text in it\n  // and cursor is either not at the start or is currently highlighting text.\n  element.selectionStart !== 0 || element.selectionEnd !== 0)) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Returns a message to be added to aria-live region when item is removed.\n *\n * @param {Object} selectionParameters Parameters required to build the message.\n * @returns {string} The a11y message.\n */\n\n\nfunction getA11yRemovalMessage(selectionParameters) {\n  const {\n    removedSelectedItem,\n    itemToString: itemToStringLocal\n  } = selectionParameters;\n  return `${itemToStringLocal(removedSelectedItem)} has been removed.`;\n}\n\nconst propTypes = {\n  selectedItems: PropTypes.array,\n  initialSelectedItems: PropTypes.array,\n  defaultSelectedItems: PropTypes.array,\n  itemToString: PropTypes.func,\n  getA11yRemovalMessage: PropTypes.func,\n  stateReducer: PropTypes.func,\n  activeIndex: PropTypes.number,\n  initialActiveIndex: PropTypes.number,\n  defaultActiveIndex: PropTypes.number,\n  onActiveIndexChange: PropTypes.func,\n  onSelectedItemsChange: PropTypes.func,\n  keyNavigationNext: PropTypes.string,\n  keyNavigationPrevious: PropTypes.string,\n  environment: PropTypes.shape({\n    addEventListener: PropTypes.func,\n    removeEventListener: PropTypes.func,\n    document: PropTypes.shape({\n      getElementById: PropTypes.func,\n      activeElement: PropTypes.any,\n      body: PropTypes.any\n    })\n  })\n};\nconst defaultProps = {\n  itemToString: defaultProps$3.itemToString,\n  stateReducer: defaultProps$3.stateReducer,\n  environment: defaultProps$3.environment,\n  getA11yRemovalMessage,\n  keyNavigationNext: 'ArrowRight',\n  keyNavigationPrevious: 'ArrowLeft'\n}; // eslint-disable-next-line import/no-mutable-exports\n\nlet validatePropTypes = noop;\n/* istanbul ignore next */\n\nif (process.env.NODE_ENV !== 'production') {\n  validatePropTypes = (options, caller) => {\n    PropTypes.checkPropTypes(propTypes, options, 'prop', caller.name);\n  };\n}\n\nconst SelectedItemClick = process.env.NODE_ENV !== \"production\" ? '__selected_item_click__' : 0;\nconst SelectedItemKeyDownDelete = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_delete__' : 1;\nconst SelectedItemKeyDownBackspace = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_backspace__' : 2;\nconst SelectedItemKeyDownNavigationNext = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_navigation_next__' : 3;\nconst SelectedItemKeyDownNavigationPrevious = process.env.NODE_ENV !== \"production\" ? '__selected_item_keydown_navigation_previous__' : 4;\nconst DropdownKeyDownNavigationPrevious = process.env.NODE_ENV !== \"production\" ? '__dropdown_keydown_navigation_previous__' : 5;\nconst DropdownKeyDownBackspace = process.env.NODE_ENV !== \"production\" ? '__dropdown_keydown_backspace__' : 6;\nconst DropdownClick = process.env.NODE_ENV !== \"production\" ? '__dropdown_click__' : 7;\nconst FunctionAddSelectedItem = process.env.NODE_ENV !== \"production\" ? '__function_add_selected_item__' : 8;\nconst FunctionRemoveSelectedItem = process.env.NODE_ENV !== \"production\" ? '__function_remove_selected_item__' : 9;\nconst FunctionSetSelectedItems = process.env.NODE_ENV !== \"production\" ? '__function_set_selected_items__' : 10;\nconst FunctionSetActiveIndex = process.env.NODE_ENV !== \"production\" ? '__function_set_active_index__' : 11;\nconst FunctionReset = process.env.NODE_ENV !== \"production\" ? '__function_reset__' : 12;\n\nvar stateChangeTypes = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  SelectedItemClick: SelectedItemClick,\n  SelectedItemKeyDownDelete: SelectedItemKeyDownDelete,\n  SelectedItemKeyDownBackspace: SelectedItemKeyDownBackspace,\n  SelectedItemKeyDownNavigationNext: SelectedItemKeyDownNavigationNext,\n  SelectedItemKeyDownNavigationPrevious: SelectedItemKeyDownNavigationPrevious,\n  DropdownKeyDownNavigationPrevious: DropdownKeyDownNavigationPrevious,\n  DropdownKeyDownBackspace: DropdownKeyDownBackspace,\n  DropdownClick: DropdownClick,\n  FunctionAddSelectedItem: FunctionAddSelectedItem,\n  FunctionRemoveSelectedItem: FunctionRemoveSelectedItem,\n  FunctionSetSelectedItems: FunctionSetSelectedItems,\n  FunctionSetActiveIndex: FunctionSetActiveIndex,\n  FunctionReset: FunctionReset\n});\n\n/* eslint-disable complexity */\n\nfunction downshiftMultipleSelectionReducer(state, action) {\n  const {\n    type,\n    index,\n    props,\n    selectedItem\n  } = action;\n  const {\n    activeIndex,\n    selectedItems\n  } = state;\n  let changes;\n\n  switch (type) {\n    case SelectedItemClick:\n      changes = {\n        activeIndex: index\n      };\n      break;\n\n    case SelectedItemKeyDownNavigationPrevious:\n      changes = {\n        activeIndex: activeIndex - 1 < 0 ? 0 : activeIndex - 1\n      };\n      break;\n\n    case SelectedItemKeyDownNavigationNext:\n      changes = {\n        activeIndex: activeIndex + 1 >= selectedItems.length ? -1 : activeIndex + 1\n      };\n      break;\n\n    case SelectedItemKeyDownBackspace:\n    case SelectedItemKeyDownDelete:\n      {\n        let newActiveIndex = activeIndex;\n\n        if (selectedItems.length === 1) {\n          newActiveIndex = -1;\n        } else if (activeIndex === selectedItems.length - 1) {\n          newActiveIndex = selectedItems.length - 2;\n        }\n\n        changes = {\n          selectedItems: [...selectedItems.slice(0, activeIndex), ...selectedItems.slice(activeIndex + 1)],\n          ...{\n            activeIndex: newActiveIndex\n          }\n        };\n        break;\n      }\n\n    case DropdownKeyDownNavigationPrevious:\n      changes = {\n        activeIndex: selectedItems.length - 1\n      };\n      break;\n\n    case DropdownKeyDownBackspace:\n      changes = {\n        selectedItems: selectedItems.slice(0, selectedItems.length - 1)\n      };\n      break;\n\n    case FunctionAddSelectedItem:\n      changes = {\n        selectedItems: [...selectedItems, selectedItem]\n      };\n      break;\n\n    case DropdownClick:\n      changes = {\n        activeIndex: -1\n      };\n      break;\n\n    case FunctionRemoveSelectedItem:\n      {\n        let newActiveIndex = activeIndex;\n        const selectedItemIndex = selectedItems.indexOf(selectedItem);\n\n        if (selectedItemIndex >= 0) {\n          if (selectedItems.length === 1) {\n            newActiveIndex = -1;\n          } else if (selectedItemIndex === selectedItems.length - 1) {\n            newActiveIndex = selectedItems.length - 2;\n          }\n\n          changes = {\n            selectedItems: [...selectedItems.slice(0, selectedItemIndex), ...selectedItems.slice(selectedItemIndex + 1)],\n            activeIndex: newActiveIndex\n          };\n        }\n\n        break;\n      }\n\n    case FunctionSetSelectedItems:\n      {\n        const {\n          selectedItems: newSelectedItems\n        } = action;\n        changes = {\n          selectedItems: newSelectedItems\n        };\n        break;\n      }\n\n    case FunctionSetActiveIndex:\n      {\n        const {\n          activeIndex: newActiveIndex\n        } = action;\n        changes = {\n          activeIndex: newActiveIndex\n        };\n        break;\n      }\n\n    case FunctionReset:\n      changes = {\n        activeIndex: getDefaultValue(props, 'activeIndex'),\n        selectedItems: getDefaultValue(props, 'selectedItems')\n      };\n      break;\n\n    default:\n      throw new Error('Reducer called without proper action type.');\n  }\n\n  return { ...state,\n    ...changes\n  };\n}\n\nuseMultipleSelection.stateChangeTypes = stateChangeTypes;\n\nfunction useMultipleSelection(userProps) {\n  if (userProps === void 0) {\n    userProps = {};\n  }\n\n  validatePropTypes(userProps, useMultipleSelection); // Props defaults and destructuring.\n\n  const props = { ...defaultProps,\n    ...userProps\n  };\n  const {\n    getA11yRemovalMessage,\n    itemToString,\n    environment,\n    keyNavigationNext,\n    keyNavigationPrevious\n  } = props; // Reducer init.\n\n  const [state, dispatch] = useControlledReducer$1(downshiftMultipleSelectionReducer, getInitialState(props), props);\n  const {\n    activeIndex,\n    selectedItems\n  } = state; // Refs.\n\n  const isInitialMountRef = useRef(true);\n  const dropdownRef = useRef(null);\n  const previousSelectedItemsRef = useRef(selectedItems);\n  const selectedItemRefs = useRef();\n  selectedItemRefs.current = [];\n  const latest = useLatestRef({\n    state,\n    props\n  }); // Effects.\n\n  /* Sets a11y status message on changes in selectedItem. */\n\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n\n    if (selectedItems.length < previousSelectedItemsRef.current.length) {\n      const removedSelectedItem = previousSelectedItemsRef.current.find(item => selectedItems.indexOf(item) < 0);\n      setStatus(getA11yRemovalMessage({\n        itemToString,\n        resultCount: selectedItems.length,\n        removedSelectedItem,\n        activeIndex,\n        activeSelectedItem: selectedItems[activeIndex]\n      }), environment.document);\n    }\n\n    previousSelectedItemsRef.current = selectedItems; // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [selectedItems.length]); // Sets focus on active item.\n\n  useEffect(() => {\n    if (isInitialMountRef.current) {\n      return;\n    }\n\n    if (activeIndex === -1 && dropdownRef.current) {\n      dropdownRef.current.focus();\n    } else if (selectedItemRefs.current[activeIndex]) {\n      selectedItemRefs.current[activeIndex].focus();\n    }\n  }, [activeIndex]);\n  useControlPropsValidator({\n    isInitialMount: isInitialMountRef.current,\n    props,\n    state\n  });\n  const setGetterPropCallInfo = useGetterPropsCalledChecker('getDropdownProps'); // Make initial ref false.\n\n  useEffect(() => {\n    isInitialMountRef.current = false;\n  }, []); // Event handler functions.\n\n  const selectedItemKeyDownHandlers = useMemo(() => ({\n    [keyNavigationPrevious]() {\n      dispatch({\n        type: SelectedItemKeyDownNavigationPrevious\n      });\n    },\n\n    [keyNavigationNext]() {\n      dispatch({\n        type: SelectedItemKeyDownNavigationNext\n      });\n    },\n\n    Delete() {\n      dispatch({\n        type: SelectedItemKeyDownDelete\n      });\n    },\n\n    Backspace() {\n      dispatch({\n        type: SelectedItemKeyDownBackspace\n      });\n    }\n\n  }), [dispatch, keyNavigationNext, keyNavigationPrevious]);\n  const dropdownKeyDownHandlers = useMemo(() => ({\n    [keyNavigationPrevious](event) {\n      if (isKeyDownOperationPermitted(event)) {\n        dispatch({\n          type: DropdownKeyDownNavigationPrevious\n        });\n      }\n    },\n\n    Backspace(event) {\n      if (isKeyDownOperationPermitted(event)) {\n        dispatch({\n          type: DropdownKeyDownBackspace\n        });\n      }\n    }\n\n  }), [dispatch, keyNavigationPrevious]); // Getter props.\n\n  const getSelectedItemProps = useCallback(function (_temp) {\n    let {\n      refKey = 'ref',\n      ref,\n      onClick,\n      onKeyDown,\n      selectedItem,\n      index,\n      ...rest\n    } = _temp === void 0 ? {} : _temp;\n    const {\n      state: latestState\n    } = latest.current;\n    const itemIndex = getItemIndex(index, selectedItem, latestState.selectedItems);\n\n    if (itemIndex < 0) {\n      throw new Error('Pass either selectedItem or index in getSelectedItemProps!');\n    }\n\n    const selectedItemHandleClick = () => {\n      dispatch({\n        type: SelectedItemClick,\n        index\n      });\n    };\n\n    const selectedItemHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && selectedItemKeyDownHandlers[key]) {\n        selectedItemKeyDownHandlers[key](event);\n      }\n    };\n\n    return {\n      [refKey]: handleRefs(ref, selectedItemNode => {\n        if (selectedItemNode) {\n          selectedItemRefs.current.push(selectedItemNode);\n        }\n      }),\n      tabIndex: index === latestState.activeIndex ? 0 : -1,\n      onClick: callAllEventHandlers(onClick, selectedItemHandleClick),\n      onKeyDown: callAllEventHandlers(onKeyDown, selectedItemHandleKeyDown),\n      ...rest\n    };\n  }, [dispatch, latest, selectedItemKeyDownHandlers]);\n  const getDropdownProps = useCallback(function (_temp2, _temp3) {\n    let {\n      refKey = 'ref',\n      ref,\n      onKeyDown,\n      onClick,\n      preventKeyAction = false,\n      ...rest\n    } = _temp2 === void 0 ? {} : _temp2;\n    let {\n      suppressRefError = false\n    } = _temp3 === void 0 ? {} : _temp3;\n    setGetterPropCallInfo('getDropdownProps', suppressRefError, refKey, dropdownRef);\n\n    const dropdownHandleKeyDown = event => {\n      const key = normalizeArrowKey(event);\n\n      if (key && dropdownKeyDownHandlers[key]) {\n        dropdownKeyDownHandlers[key](event);\n      }\n    };\n\n    const dropdownHandleClick = () => {\n      dispatch({\n        type: DropdownClick\n      });\n    };\n\n    return {\n      [refKey]: handleRefs(ref, dropdownNode => {\n        if (dropdownNode) {\n          dropdownRef.current = dropdownNode;\n        }\n      }),\n      ...(!preventKeyAction && {\n        onKeyDown: callAllEventHandlers(onKeyDown, dropdownHandleKeyDown),\n        onClick: callAllEventHandlers(onClick, dropdownHandleClick)\n      }),\n      ...rest\n    };\n  }, [dispatch, dropdownKeyDownHandlers, setGetterPropCallInfo]); // returns\n\n  const addSelectedItem = useCallback(selectedItem => {\n    dispatch({\n      type: FunctionAddSelectedItem,\n      selectedItem\n    });\n  }, [dispatch]);\n  const removeSelectedItem = useCallback(selectedItem => {\n    dispatch({\n      type: FunctionRemoveSelectedItem,\n      selectedItem\n    });\n  }, [dispatch]);\n  const setSelectedItems = useCallback(newSelectedItems => {\n    dispatch({\n      type: FunctionSetSelectedItems,\n      selectedItems: newSelectedItems\n    });\n  }, [dispatch]);\n  const setActiveIndex = useCallback(newActiveIndex => {\n    dispatch({\n      type: FunctionSetActiveIndex,\n      activeIndex: newActiveIndex\n    });\n  }, [dispatch]);\n  const reset = useCallback(() => {\n    dispatch({\n      type: FunctionReset\n    });\n  }, [dispatch]);\n  return {\n    getSelectedItemProps,\n    getDropdownProps,\n    addSelectedItem,\n    removeSelectedItem,\n    setSelectedItems,\n    setActiveIndex,\n    reset,\n    selectedItems,\n    activeIndex\n  };\n}\n\nexport { Downshift$1 as default, resetIdCounter, useCombobox, useMultipleSelection, useSelect };\n","import Downshift from 'downshift'\nimport React from 'react'\nimport { useState } from 'react'\nimport { getUserGroupHeaders } from '../../synapse-client/SynapseClient'\nimport {\n  UserGroupHeader,\n  UserGroupHeaderResponsePage,\n} from '@sage-bionetworks/synapse-types'\nimport { TYPE_FILTER } from '@sage-bionetworks/synapse-types'\nimport UserOrTeamBadge from '../UserOrTeamBadge/UserOrTeamBadge'\n\nexport type UserSearchBoxProps = {\n  id?: string // id for the input tag\n  onSelectCallback?: (selected: UserGroupHeader) => void\n  typeFilter?: TYPE_FILTER\n  filterUserIds?: string[]\n}\n\nconst UserSearchBox: React.FC<UserSearchBoxProps> = props => {\n  const { id, onSelectCallback, filterUserIds, typeFilter } = props\n  const [users, setUsers] = useState<UserGroupHeader[]>([])\n\n  const onInputValueChange = async (inputValue: string) => {\n    try {\n      const headers: UserGroupHeaderResponsePage = await getUserGroupHeaders(\n        inputValue,\n        typeFilter,\n      )\n      const filtered: UserGroupHeader[] = filterUserIds?.length\n        ? headers.children.filter((user: UserGroupHeader) => {\n            return !filterUserIds.includes(user.ownerId)\n          })\n        : headers.children\n      setUsers(filtered)\n    } catch (e) {\n      console.log('onInputValueChange', e)\n    }\n  }\n\n  const onSelectedItem = (selected: UserGroupHeader) => {\n    if (onSelectCallback) {\n      onSelectCallback(selected)\n    }\n  }\n\n  return (\n    <>\n      <Downshift\n        onInputValueChange={inputValue => {\n          onInputValueChange(inputValue)\n        }}\n        onChange={selectedItem => onSelectedItem(selectedItem)}\n        itemToString={item => (item?.name ? item.name : '')}\n      >\n        {({\n          getInputProps,\n          getMenuProps,\n          getItemProps,\n          isOpen,\n          inputValue,\n        }) => (\n          <div className={'user-search-box'}>\n            <input\n              {...getInputProps({\n                className: 'form-control',\n                id: id,\n                type: 'search',\n                role: 'searchbox',\n                placeholder: 'Enter the name...',\n              })}\n              style={{ marginBottom: '0' }}\n            />\n            <ul\n              {...getMenuProps()}\n              className={isOpen ? 'users-visible' : ''}\n              role=\"list\"\n            >\n              {isOpen\n                ? users\n                    .filter(\n                      (user: UserGroupHeader) =>\n                        !inputValue ||\n                        `${user.firstName} ${user.lastName}`.includes(\n                          inputValue,\n                        ) ||\n                        user.userName.includes(inputValue),\n                    )\n                    .map((item, index) => (\n                      <li\n                        key={`userSearchBox-${index}`}\n                        {...getItemProps({ key: item.ownerId, index, item })}\n                      >\n                        <UserOrTeamBadge\n                          userGroupHeader={item}\n                          disableHref={true}\n                          showFullName={true}\n                        />\n                      </li>\n                    ))\n                : null}\n            </ul>\n          </div>\n        )}\n      </Downshift>\n    </>\n  )\n}\n\nexport default UserSearchBox\n"],"names":["t","e","n","r","i","o","l","d","f","h","u","s","a","c","g","p","m","w","v","W","H","b","y","E","M","V","x","I","C","R","T","k","B","D","O","X","Y","L","S","j","N","q","z","A","F","G","J","K","P","Q","U","Z","$","idCounter","cbToCb","cb","noop","scrollIntoView","node","menuNode","computeScrollIntoView","_ref","el","top","left","isOrContainsNode","parent","child","environment","debounce","fn","time","timeoutId","cancel","wrapper","_len","args","_key","callAllEventHandlers","_len2","fns","_key2","event","_len3","_key3","handleRefs","_len4","refs","_key4","ref","generateId","getA11yStatusMessage$1","_ref2","isOpen","resultCount","previousResultCount","unwrapArray","arg","defaultValue","isDOMElement","element","getElementProps","stateKeys","pickState","state","result","getState","props","prevState","key","isControlledProp","normalizeArrowKey","keyCode","getNextWrappingIndex","moveAmount","baseIndex","itemCount","getItemNodeFromIndex","circular","itemsLastIndex","newIndex","nonDisabledNewIndex","getNextNonDisabledIndex","currentElementNode","index","targetWithinDownshift","target","downshiftElements","checkActiveElement","contextNode","cleanupStatus","documentProp","getStatusDiv","setStatus","status","div","statusDiv","unknown","mouseUp","itemMouseEnter","keyDownArrowUp","keyDownArrowDown","keyDownEscape","keyDownEnter","keyDownHome","keyDownEnd","clickItem","blurInput","changeInput","keyDownSpaceButton","clickButton","blurButton","controlledPropUpdatedSelectedItem","touchEnd","stateChangeTypes$3","Downshift","Component","_props","_this","id","count","highlightedIndex","otherStateToSet","item","itemIndex","stateToSet","isItemSelected","onChangeArg","onStateChangeArg","isStateToSetFunction","newStateToSet","nextState","_temp","_temp2","refKey","rest","suppressRefError","amount","nextHighlightedIndex","itemNode","newHighlightedIndex","_temp3","onClick","onPress","onKeyDown","onKeyUp","onBlur","enabledEventHandlers","eventHandlers","blurTarget","_temp4","onChange","onInput","onChangeText","onChangeKey","inputValue","downshiftButtonIsActive","_temp5","_temp6","_temp7","onMouseMove","onMouseDown","onSelectKey","customClickHandler","selectedItem","defaultHighlightedIndex","_highlightedIndex","defaultIsOpen","_isOpen","_inputValue","_selectedItem","_state","stateToMerge","itemToString","getRootProps","getToggleButtonProps","getLabelProps","getMenuProps","getInputProps","getItemProps","openMenu","closeMenu","toggleMenu","selectItem","selectItemAtIndex","selectHighlightedItem","setHighlightedIndex","clearSelection","clearItems","reset","setItemCount","unsetItemCount","setState","onMouseUp","onTouchStart","onTouchMove","onTouchEnd","contextWithinDownshift","prevProps","currentHighlightedIndex","prevHighlightedIndex","children","cloneElement","prevItem","Downshift$1","stateReducer","getA11ySelectionMessage","selectionParameters","itemToStringLocal","getA11yMessage","document","defaultProps$3","PropTypes","getA11yStatusMessage","_a","__assign","getA11yRemovalMessage","removedSelectedItem","UserSearchBox","onSelectCallback","filterUserIds","typeFilter","users","setUsers","useState","onInputValueChange","headers","getUserGroupHeaders","filtered","user","onSelectedItem","selected","jsx","Fragment","jsxs","UserOrTeamBadge"],"mappings":"+kFAAA,SAASA,GAAEA,EAAE,CAAC,OAAgB,OAAOA,GAAjB,UAA0BA,GAAN,MAAaA,EAAE,WAAN,CAAc,CAAC,SAASC,GAAED,EAAEC,EAAE,CAAC,OAAO,CAACA,GAAcD,IAAX,WAA2BA,IAAZ,WAAwBA,IAAT,MAAU,CAAC,SAASE,GAAEF,EAAEE,EAAE,CAAC,GAAGF,EAAE,aAAaA,EAAE,cAAcA,EAAE,YAAYA,EAAE,YAAY,CAAC,IAAIG,EAAE,iBAAiBH,EAAE,IAAI,EAAE,OAAOC,GAAEE,EAAE,UAAUD,CAAC,GAAGD,GAAEE,EAAE,UAAUD,CAAC,GAAG,SAASF,EAAE,CAAC,IAAIC,EAAE,SAASD,EAAE,CAAC,GAAG,CAACA,EAAE,eAAe,CAACA,EAAE,cAAc,YAAY,OAAO,KAAK,GAAG,CAAC,OAAOA,EAAE,cAAc,YAAY,YAAY,MAAS,CAAC,OAAO,IAAI,CAAC,EAAEA,CAAC,EAAE,MAAM,CAAC,CAACC,IAAIA,EAAE,aAAaD,EAAE,cAAcC,EAAE,YAAYD,EAAE,YAAY,EAAEA,CAAC,CAAC,CAAC,MAAM,EAAE,CAAC,SAASG,EAAEH,EAAEC,EAAE,EAAEE,EAAEC,EAAEC,EAAEC,EAAEC,EAAE,CAAC,OAAOF,EAAEL,GAAGM,EAAEL,GAAGI,EAAEL,GAAGM,EAAEL,EAAE,EAAEI,GAAGL,GAAGO,GAAG,GAAGD,GAAGL,GAAGM,GAAG,EAAEF,EAAEL,EAAEG,EAAEG,EAAEL,GAAGM,EAAE,GAAGF,EAAEL,GAAGO,EAAE,EAAED,EAAEL,EAAEG,EAAE,CAAC,CAAC,IAAIA,GAAE,SAASH,EAAEG,EAAE,CAAC,IAAIC,EAAE,OAAOC,EAAEF,EAAE,WAAWG,EAAEH,EAAE,MAAMI,EAAEJ,EAAE,OAAOK,EAAEL,EAAE,SAASM,EAAEN,EAAE,2BAA2BO,EAAc,OAAOF,GAAnB,WAAqBA,EAAE,SAAST,GAAE,CAAC,OAAOA,KAAIS,CAAC,EAAE,GAAG,CAACT,GAAEC,CAAC,EAAE,MAAM,IAAI,UAAU,gBAAgB,EAAE,QAAQW,EAAEC,EAAEC,EAAE,SAAS,kBAAkB,SAAS,gBAAgBC,EAAE,CAAE,EAACC,EAAEf,EAAED,GAAEgB,CAAC,GAAGL,EAAEK,CAAC,GAAG,CAAC,IAAIA,GAASH,GAAGD,EAAEI,GAAG,gBAAf,KAA8BJ,EAAE,YAAa,EAAC,MAAM,KAAKC,KAAKC,EAAE,CAACC,EAAE,KAAKC,CAAC,EAAE,KAAK,CAAOA,GAAN,MAASA,IAAI,SAAS,MAAMd,GAAEc,CAAC,GAAG,CAACd,GAAE,SAAS,eAAe,GAASc,GAAN,MAASd,GAAEc,EAAEN,CAAC,GAAGK,EAAE,KAAKC,CAAC,CAAC,CAAC,QAAQC,EAAEZ,EAAE,eAAeA,EAAE,eAAe,MAAM,WAAWa,EAAEb,EAAE,eAAeA,EAAE,eAAe,OAAO,YAAYc,EAAE,OAAO,SAAS,YAAYC,EAAE,OAAO,SAAS,YAAYC,EAAEpB,EAAE,sBAAuB,EAACqB,EAAED,EAAE,OAAOE,EAAEF,EAAE,MAAMG,EAAEH,EAAE,IAAII,EAAEJ,EAAE,MAAMK,EAAEL,EAAE,OAAOM,EAAEN,EAAE,KAAKO,EAAYrB,IAAV,SAAyBA,IAAZ,UAAciB,EAAUjB,IAAR,MAAUmB,EAAEF,EAAEF,EAAE,EAAEO,EAAarB,IAAX,SAAamB,EAAEJ,EAAE,EAAUf,IAAR,MAAUiB,EAAEE,EAAEG,EAAE,CAAA,EAAGC,GAAE,EAAEA,GAAEhB,EAAE,OAAOgB,KAAI,CAAC,IAAIC,EAAEjB,EAAEgB,EAAC,EAAEE,EAAED,EAAE,sBAAqB,EAAGE,EAAED,EAAE,OAAOE,EAAEF,EAAE,MAAMG,EAAEH,EAAE,IAAII,GAAEJ,EAAE,MAAMK,GAAEL,EAAE,OAAOM,EAAEN,EAAE,KAAK,GAAiB3B,IAAd,aAAiBkB,GAAG,GAAGG,GAAG,GAAGD,GAAGR,GAAGO,GAAGR,GAAGO,GAAGY,GAAGV,GAAGY,IAAGX,GAAGY,GAAGd,GAAGY,GAAE,OAAOP,EAAE,IAAIU,EAAE,iBAAiBR,CAAC,EAAES,EAAE,SAASD,EAAE,gBAAgB,EAAE,EAAEE,EAAE,SAASF,EAAE,eAAe,EAAE,EAAEG,EAAE,SAASH,EAAE,iBAAiB,EAAE,EAAEI,EAAE,SAASJ,EAAE,kBAAkB,EAAE,EAAEK,EAAE,EAAEC,EAAE,EAAEC,EAAE,gBAAgBf,EAAEA,EAAE,YAAYA,EAAE,YAAYS,EAAEE,EAAE,EAAEK,EAAE,iBAAiBhB,EAAEA,EAAE,aAAaA,EAAE,aAAaU,EAAEE,EAAE,EAAEK,GAAE,gBAAgBjB,EAAMA,EAAE,cAAN,EAAkB,EAAEG,EAAEH,EAAE,YAAY,EAAEkB,GAAE,iBAAiBlB,EAAMA,EAAE,eAAN,EAAmB,EAAEE,EAAEF,EAAE,aAAa,EAAE,GAAGlB,IAAIkB,EAAEa,EAAYtC,IAAV,QAAYqB,EAAUrB,IAAR,MAAUqB,EAAEV,EAAcX,IAAZ,UAAcJ,EAAEiB,EAAEA,EAAEF,EAAEA,EAAEwB,EAAEE,EAAExB,EAAEQ,EAAER,EAAEQ,EAAEN,EAAEA,CAAC,EAAEM,EAAEV,EAAE,EAAE4B,EAAYtC,IAAV,QAAYqB,EAAarB,IAAX,SAAaqB,EAAEZ,EAAE,EAAUT,IAAR,MAAUqB,EAAEZ,EAAEd,EAAEgB,EAAEA,EAAEF,EAAEA,EAAEwB,EAAEE,EAAExB,EAAEU,EAAEV,EAAEU,EAAEN,EAAEA,CAAC,EAAEsB,EAAE,KAAK,IAAI,EAAEA,EAAEzB,CAAC,EAAE0B,EAAE,KAAK,IAAI,EAAEA,EAAE3B,CAAC,MAAM,CAAC0B,EAAYtC,IAAV,QAAYqB,EAAEQ,EAAEM,EAAUnC,IAAR,MAAUqB,EAAEU,GAAEM,EAAEI,EAAczC,IAAZ,UAAcJ,EAAEiC,EAAEE,GAAEJ,EAAEQ,EAAEE,EAAEI,EAAEpB,EAAEA,EAAEN,EAAEA,CAAC,EAAEM,GAAGQ,EAAEF,EAAE,GAAGc,EAAE,EAAEF,EAAYtC,IAAV,QAAYqB,EAAEU,EAAEE,EAAajC,IAAX,SAAaqB,GAAGU,EAAEJ,EAAE,GAAGY,EAAE,EAAUvC,IAAR,MAAUqB,EAAEQ,GAAEM,EAAEI,EAAE5C,EAAEoC,EAAEF,GAAEF,EAAEM,EAAEE,EAAEI,EAAElB,EAAEA,EAAEN,EAAEA,CAAC,EAAE,IAAI4B,GAAEnB,EAAE,WAAWoB,GAAEpB,EAAE,UAAUJ,GAAGwB,IAAGP,EAAE,KAAK,IAAI,EAAE,KAAK,IAAIO,GAAEP,EAAEK,GAAElB,EAAE,aAAaE,EAAEgB,GAAEF,CAAC,CAAC,GAAGnB,GAAGsB,IAAGL,EAAE,KAAK,IAAI,EAAE,KAAK,IAAIK,GAAEL,EAAEG,GAAEjB,EAAE,YAAYG,EAAEc,GAAEF,CAAC,CAAC,EAAE,CAACjB,EAAE,KAAK,CAAC,GAAGE,EAAE,IAAIa,EAAE,KAAKC,CAAC,CAAC,CAAC,CAAC,OAAOhB,CAAC,ECM7kF,IAAIuB,GAAY,EAUhB,SAASC,GAAOC,EAAI,CAClB,OAAO,OAAOA,GAAO,WAAaA,EAAKC,CACzC,CAEA,SAASA,GAAO,CAAE,CAQlB,SAASC,GAAeC,EAAMC,EAAU,CACtC,GAAI,CAACD,EACH,OAGcE,GAAsBF,EAAM,CAC1C,SAAUC,EACV,MAAO,UACP,WAAY,WAChB,CAAG,EACO,QAAQE,GAAQ,CACtB,GAAI,CACF,GAAAC,EACA,IAAAC,EACA,KAAAC,CACD,EAAGH,EACJC,EAAG,UAAYC,EACfD,EAAG,WAAaE,CACpB,CAAG,CACH,CASA,SAASC,GAAiBC,EAAQC,EAAOC,EAAa,CAEpD,OADeF,IAAWC,GAASA,aAAiBC,EAAY,MAAQF,EAAO,UAAYA,EAAO,SAASC,CAAK,CAElH,CAWA,SAASE,GAASC,EAAIC,EAAM,CAC1B,IAAIC,EAEJ,SAASC,GAAS,CACZD,GACF,aAAaA,CAAS,CAEzB,CAED,SAASE,GAAU,CACjB,QAASC,EAAO,UAAU,OAAQC,EAAO,IAAI,MAAMD,CAAI,EAAGE,EAAO,EAAGA,EAAOF,EAAME,IAC/ED,EAAKC,CAAI,EAAI,UAAUA,CAAI,EAG7BJ,IACAD,EAAY,WAAW,IAAM,CAC3BA,EAAY,KACZF,EAAG,GAAGM,CAAI,CACX,EAAEL,CAAI,CACR,CAED,OAAAG,EAAQ,OAASD,EACVC,CACT,CAUA,SAASI,GAAuB,CAC9B,QAASC,EAAQ,UAAU,OAAQC,EAAM,IAAI,MAAMD,CAAK,EAAGE,EAAQ,EAAGA,EAAQF,EAAOE,IACnFD,EAAIC,CAAK,EAAI,UAAUA,CAAK,EAG9B,OAAO,SAAUC,EAAO,CACtB,QAASC,EAAQ,UAAU,OAAQP,EAAO,IAAI,MAAMO,EAAQ,EAAIA,EAAQ,EAAI,CAAC,EAAGC,EAAQ,EAAGA,EAAQD,EAAOC,IACxGR,EAAKQ,EAAQ,CAAC,EAAI,UAAUA,CAAK,EAGnC,OAAOJ,EAAI,KAAKV,IACVA,GACFA,EAAGY,EAAO,GAAGN,CAAI,EAGZM,EAAM,yBAA2BA,EAAM,eAAe,aAAa,GAAKA,EAAM,YAAY,wBAClG,CACL,CACA,CAEA,SAASG,IAAa,CACpB,QAASC,EAAQ,UAAU,OAAQC,EAAO,IAAI,MAAMD,CAAK,EAAGE,EAAQ,EAAGA,EAAQF,EAAOE,IACpFD,EAAKC,CAAK,EAAI,UAAUA,CAAK,EAG/B,OAAO9B,GAAQ,CACb6B,EAAK,QAAQE,GAAO,CACd,OAAOA,GAAQ,WACjBA,EAAI/B,CAAI,EACC+B,IACTA,EAAI,QAAU/B,EAEtB,CAAK,CACL,CACA,CAOA,SAASgC,IAAa,CACpB,OAAO,OAAOrC,IAAW,CAC3B,CAmBA,SAASsC,GAAuBC,EAAO,CACrC,GAAI,CACF,OAAAC,EACA,YAAAC,EACA,oBAAAC,CACD,EAAGH,EAEJ,OAAKC,EAIAC,EAIDA,IAAgBC,EACX,GAAGD,CAAW,UAAUA,IAAgB,EAAI,MAAQ,OAAO,iFAG7D,GAPE,4BAJA,EAYX,CAUA,SAASE,GAAYC,EAAKC,EAAc,CAKtC,OAJAD,EAAM,MAAM,QAAQA,CAAG,EAEvBA,EAAI,CAAC,EAAIA,EAEL,CAACA,GAAOC,EACHA,EAEAD,CAEX,CAOA,SAASE,GAAaC,EAAS,CAG7B,OAAO,OAAOA,EAAQ,MAAS,QACjC,CAOA,SAASC,GAAgBD,EAAS,CAEhC,OAAOA,EAAQ,KACjB,CAcA,MAAME,GAAY,CAAC,mBAAoB,aAAc,SAAU,eAAgB,MAAM,EAMrF,SAASC,EAAUC,EAAO,CACpBA,IAAU,SACZA,EAAQ,CAAA,GAGV,MAAMC,EAAS,CAAA,EACf,OAAAH,GAAU,QAAQvE,GAAK,CACjByE,EAAM,eAAezE,CAAC,IACxB0E,EAAO1E,CAAC,EAAIyE,EAAMzE,CAAC,EAEzB,CAAG,EACM0E,CACT,CAcA,SAASC,GAASF,EAAOG,EAAO,CAC9B,OAAO,OAAO,KAAKH,CAAK,EAAE,OAAO,CAACI,EAAWC,KAC3CD,EAAUC,CAAG,EAAIC,GAAiBH,EAAOE,CAAG,EAAIF,EAAME,CAAG,EAAIL,EAAMK,CAAG,EAC/DD,GACN,CAAE,CAAA,CACP,CAYA,SAASE,GAAiBH,EAAOE,EAAK,CACpC,OAAOF,EAAME,CAAG,IAAM,MACxB,CAQA,SAASE,GAAkB7B,EAAO,CAChC,KAAM,CACJ,IAAA2B,EACA,QAAAG,CACD,EAAG9B,EAGJ,OAAI8B,GAAW,IAAMA,GAAW,IAAMH,EAAI,QAAQ,OAAO,IAAM,EACtD,QAAQA,CAAG,GAGbA,CACT,CAwBA,SAASI,GAAqBC,EAAYC,EAAWC,EAAWC,EAAsBC,EAAU,CAK9F,GAJIA,IAAa,SACfA,EAAW,IAGTF,IAAc,EAChB,MAAO,GAGT,MAAMG,EAAiBH,EAAY,GAE/B,OAAOD,GAAc,UAAYA,EAAY,GAAKA,GAAaC,KACjED,EAAYD,EAAa,EAAI,GAAKK,EAAiB,GAGrD,IAAIC,EAAWL,EAAYD,EAEvBM,EAAW,EACbA,EAAWF,EAAWC,EAAiB,EAC9BC,EAAWD,IACpBC,EAAWF,EAAW,EAAIC,GAG5B,MAAME,EAAsBC,EAAwBR,EAAYM,EAAUJ,EAAWC,EAAsBC,CAAQ,EAEnH,OAAIG,IAAwB,GACnBN,GAAaC,EAAY,GAAKD,EAGhCM,CACT,CAaA,SAASC,EAAwBR,EAAYC,EAAWC,EAAWC,EAAsBC,EAAU,CACjG,MAAMK,EAAqBN,EAAqBF,CAAS,EAEzD,GAAI,CAACQ,GAAsB,CAACA,EAAmB,aAAa,UAAU,EACpE,OAAOR,EAGT,GAAID,EAAa,GACf,QAASU,EAAQT,EAAY,EAAGS,EAAQR,EAAWQ,IACjD,GAAI,CAACP,EAAqBO,CAAK,EAAE,aAAa,UAAU,EACtD,OAAOA,MAIX,SAASA,EAAQT,EAAY,EAAGS,GAAS,EAAGA,IAC1C,GAAI,CAACP,EAAqBO,CAAK,EAAE,aAAa,UAAU,EACtD,OAAOA,EAKb,OAAIN,EACKJ,EAAa,EAAIQ,EAAwB,EAAG,EAAGN,EAAWC,EAAsB,EAAK,EAAIK,EAAwB,GAAIN,EAAY,EAAGA,EAAWC,EAAsB,EAAK,EAG5K,EACT,CAaA,SAASQ,GAAsBC,EAAQC,EAAmB3D,EAAa4D,EAAoB,CACzF,OAAIA,IAAuB,SACzBA,EAAqB,IAGhBD,EAAkB,KAAKE,GAAeA,IAAgBhE,GAAiBgE,EAAaH,EAAQ1D,CAAW,GAAK4D,GAAsB/D,GAAiBgE,EAAa7D,EAAY,SAAS,cAAeA,CAAW,EAAE,CAC1N,CAqBA,MAAM8D,GAAgB7D,GAAS8D,GAAgB,CAC7CC,GAAaD,CAAY,EAAE,YAAc,EAC3C,EAAG,GAAG,EAMN,SAASE,GAAUC,EAAQH,EAAc,CACvC,MAAMI,EAAMH,GAAaD,CAAY,EAEhCG,IAILC,EAAI,YAAcD,EAClBJ,GAAcC,CAAY,EAC5B,CAQA,SAASC,GAAaD,EAAc,CAC9BA,IAAiB,SACnBA,EAAe,UAGjB,IAAIK,EAAYL,EAAa,eAAe,qBAAqB,EAEjE,OAAIK,IAIJA,EAAYL,EAAa,cAAc,KAAK,EAC5CK,EAAU,aAAa,KAAM,qBAAqB,EAClDA,EAAU,aAAa,OAAQ,QAAQ,EACvCA,EAAU,aAAa,YAAa,QAAQ,EAC5CA,EAAU,aAAa,gBAAiB,gBAAgB,EACxD,OAAO,OAAOA,EAAU,MAAO,CAC7B,OAAQ,IACR,KAAM,gBACN,OAAQ,MACR,OAAQ,OACR,SAAU,SACV,QAAS,IACT,SAAU,WACV,MAAO,KACX,CAAG,EACDL,EAAa,KAAK,YAAYK,CAAS,EAChCA,EACT,CAEA,MAAMC,GAA+E,EAC/EC,GAA+E,EAC/EC,GAA8F,EAC9FC,EAA+F,EAC/FC,EAAmG,EACnGC,GAA4F,EAC5FC,GAA0F,EAC1FC,GAAwF,EACxFC,GAAsF,EACtFC,GAAoF,EACpFC,GAAoF,GACpFC,GAAwF,GACxFC,GAAuG,GACvGC,GAAwF,GACxFC,GAAsF,GACtFC,GAAuI,GACvIC,GAAiF,GAEvF,IAAIC,GAAkC,OAAO,OAAO,CAClD,UAAW,KACX,QAASjB,GACT,QAASC,GACT,eAAgBC,GAChB,eAAgBC,EAChB,iBAAkBC,EAClB,cAAeC,GACf,aAAcC,GACd,YAAaC,GACb,WAAYC,GACZ,UAAWC,GACX,UAAWC,GACX,YAAaC,GACb,mBAAoBC,GACpB,YAAaC,GACb,WAAYC,GACZ,kCAAmCC,GACnC,SAAUC,EACZ,CAAC,EAID,MAAME,IAA0B,IAAM,CACpC,MAAMA,UAAkBC,GAAAA,SAAU,CAChC,YAAYC,EAAQ,CAClB,IAAIC,EAEJ,MAAMD,CAAM,EACZC,EAAQ,KACR,KAAK,GAAK,KAAK,MAAM,IAAM,aAAapE,GAAY,CAAA,GACpD,KAAK,OAAS,KAAK,MAAM,QAAU,GAAG,KAAK,EAAE,QAC7C,KAAK,QAAU,KAAK,MAAM,SAAW,GAAG,KAAK,EAAE,SAC/C,KAAK,QAAU,KAAK,MAAM,SAAW,GAAG,KAAK,EAAE,SAE/C,KAAK,UAAY,KAAK,MAAM,YAAckC,GAAS,GAAG,KAAK,EAAE,SAASA,CAAK,IAE3E,KAAK,MAAQ,KACb,KAAK,MAAQ,GACb,KAAK,UAAY,KACjB,KAAK,oBAAsB,EAC3B,KAAK,WAAa,GAElB,KAAK,mBAAqB,CAACtD,EAAIC,IAAS,CACtC,MAAMwF,EAAK,WAAW,IAAM,CAC1B,KAAK,WAAa,KAAK,WAAW,OAAO3J,GAAKA,IAAM2J,CAAE,EACtDzF,GACD,EAAEC,CAAI,EACP,KAAK,WAAW,KAAKwF,CAAE,CAC/B,EAEM,KAAK,aAAeC,GAAS,CAC3B,KAAK,UAAYA,CACzB,EAEM,KAAK,eAAiB,IAAM,CAC1B,KAAK,UAAY,IACzB,EAEM,KAAK,oBAAsB,SAAUC,EAAkBC,EAAiB,CAClED,IAAqB,SACvBA,EAAmBH,EAAM,MAAM,yBAG7BI,IAAoB,SACtBA,EAAkB,CAAA,GAGpBA,EAAkB3D,EAAU2D,CAAe,EAE3CJ,EAAM,iBAAiB,CACrB,iBAAAG,EACA,GAAGC,CACb,CAAS,CACT,EAEM,KAAK,eAAiB3G,GAAM,CAC1B,KAAK,iBAAiB,CACpB,aAAc,KACd,WAAY,GACZ,iBAAkB,KAAK,MAAM,wBAC7B,OAAQ,KAAK,MAAM,aACpB,EAAEA,CAAE,CACb,EAEM,KAAK,WAAa,CAAC4G,EAAMD,EAAiB3G,IAAO,CAC/C2G,EAAkB3D,EAAU2D,CAAe,EAC3C,KAAK,iBAAiB,CACpB,OAAQ,KAAK,MAAM,cACnB,iBAAkB,KAAK,MAAM,wBAC7B,aAAcC,EACd,WAAY,KAAK,MAAM,aAAaA,CAAI,EACxC,GAAGD,CACJ,EAAE3G,CAAE,CACb,EAEM,KAAK,kBAAoB,CAAC6G,EAAWF,EAAiB3G,IAAO,CAC3D,MAAM4G,EAAO,KAAK,MAAMC,CAAS,EAE7BD,GAAQ,MAIZ,KAAK,WAAWA,EAAMD,EAAiB3G,CAAE,CACjD,EAEM,KAAK,sBAAwB,CAAC2G,EAAiB3G,IACtC,KAAK,kBAAkB,KAAK,SAAU,EAAC,iBAAkB2G,EAAiB3G,CAAE,EAGrF,KAAK,iBAAmB,CAAC8G,EAAY9G,IAAO,CAC1C,IAAI+G,EAAgBC,EACpB,MAAMC,EAAmB,CAAA,EACnBC,EAAuB,OAAOJ,GAAe,WAMnD,MAAI,CAACI,GAAwBJ,EAAW,eAAe,YAAY,GACjE,KAAK,MAAM,mBAAmBA,EAAW,WAAY,CAAE,GAAG,KAAK,mBAAoB,EACjF,GAAGA,CACf,CAAW,EAGI,KAAK,SAAS7D,GAAS,CAC5BA,EAAQ,KAAK,SAASA,CAAK,EAC3B,IAAIkE,EAAgBD,EAAuBJ,EAAW7D,CAAK,EAAI6D,EAE/DK,EAAgB,KAAK,MAAM,aAAalE,EAAOkE,CAAa,EAI5DJ,EAAiBI,EAAc,eAAe,cAAc,EAE5D,MAAMC,EAAY,CAAA,EAIlB,OAAIL,GAAkBI,EAAc,eAAiBlE,EAAM,eACzD+D,EAAcG,EAAc,cAG9BA,EAAc,KAAOA,EAAc,MAAQjC,GAC3C,OAAO,KAAKiC,CAAa,EAAE,QAAQ7D,GAAO,CAGpCL,EAAMK,CAAG,IAAM6D,EAAc7D,CAAG,IAClC2D,EAAiB3D,CAAG,EAAI6D,EAAc7D,CAAG,GASvCA,IAAQ,SAIZ6D,EAAc7D,CAAG,EAEZC,GAAiB,KAAK,MAAOD,CAAG,IACnC8D,EAAU9D,CAAG,EAAI6D,EAAc7D,CAAG,GAEhD,CAAW,EAGG4D,GAAwBC,EAAc,eAAe,YAAY,GACnE,KAAK,MAAM,mBAAmBA,EAAc,WAAY,CAAE,GAAG,KAAK,mBAAoB,EACpF,GAAGA,CACjB,CAAa,EAGIC,CACjB,EAAW,IAAM,CAEPrH,GAAOC,CAAE,IAGoB,OAAO,KAAKiH,CAAgB,EAAE,OAAS,GAGlE,KAAK,MAAM,cAAcA,EAAkB,KAAK,mBAAkB,CAAE,EAGlEF,GACF,KAAK,MAAM,SAASD,EAAW,aAAc,KAAK,mBAAkB,CAAE,EAGpEE,IAAgB,QAClB,KAAK,MAAM,SAASA,EAAa,KAAK,mBAAkB,CAAE,EAK5D,KAAK,MAAM,aAAaC,EAAkB,KAAK,mBAAkB,CAAE,CAC7E,CAAS,CACT,EAEM,KAAK,QAAU9G,GAAQ,KAAK,UAAYA,EAExC,KAAK,aAAe,SAAUkH,EAAOC,EAAQ,CAC3C,GAAI,CACF,OAAAC,EAAS,MACT,IAAArF,EACA,GAAGsF,CACJ,EAAGH,IAAU,OAAS,CAAA,EAAKA,EACxB,CACF,iBAAAI,EAAmB,EACpB,EAAGH,IAAW,OAAS,CAAA,EAAKA,EAG7Bf,EAAM,aAAa,OAAS,GAC5BA,EAAM,aAAa,OAASgB,EAC5BhB,EAAM,aAAa,iBAAmBkB,EAEtC,KAAM,CACJ,OAAAnF,CACV,EAAYiE,EAAM,WAEV,MAAO,CACL,CAACgB,CAAM,EAAGzF,GAAWI,EAAKqE,EAAM,OAAO,EACvC,KAAM,WACN,gBAAiBjE,EACjB,gBAAiB,UACjB,YAAaA,EAASiE,EAAM,OAAS,KACrC,kBAAmBA,EAAM,QACzB,GAAGiB,CACb,CACA,EAEM,KAAK,gBAAkB,CACrB,UAAU7F,EAAO,CAGf,GAFAA,EAAM,eAAc,EAEhB,KAAK,SAAU,EAAC,OAAQ,CAC1B,MAAM+F,EAAS/F,EAAM,SAAW,EAAI,EACpC,KAAK,qBAAqB+F,EAAQ,CAChC,KAAMpC,CACpB,CAAa,CACb,MACY,KAAK,iBAAiB,CACpB,OAAQ,GACR,KAAMA,CACpB,EAAe,IAAM,CACP,MAAMzB,EAAY,KAAK,eAEvB,GAAIA,EAAY,EAAG,CACjB,KAAM,CACJ,iBAAA6C,CAClB,EAAoB,KAAK,WACHiB,EAAuBjE,GAAqB,EAAGgD,EAAkB7C,EAAWQ,GAAS,KAAK,qBAAqBA,CAAK,CAAC,EAC3H,KAAK,oBAAoBsD,EAAsB,CAC7C,KAAMrC,CACxB,CAAiB,CACF,CACf,CAAa,CAEJ,EAED,QAAQ3D,EAAO,CAGb,GAFAA,EAAM,eAAc,EAEhB,KAAK,SAAU,EAAC,OAAQ,CAC1B,MAAM+F,EAAS/F,EAAM,SAAW,GAAK,GACrC,KAAK,qBAAqB+F,EAAQ,CAChC,KAAMrC,CACpB,CAAa,CACb,MACY,KAAK,iBAAiB,CACpB,OAAQ,GACR,KAAMA,CACpB,EAAe,IAAM,CACP,MAAMxB,EAAY,KAAK,eAEvB,GAAIA,EAAY,EAAG,CACjB,KAAM,CACJ,iBAAA6C,CAClB,EAAoB,KAAK,WACHiB,EAAuBjE,GAAqB,GAAIgD,EAAkB7C,EAAWQ,GAAS,KAAK,qBAAqBA,CAAK,CAAC,EAC5H,KAAK,oBAAoBsD,EAAsB,CAC7C,KAAMtC,CACxB,CAAiB,CACF,CACf,CAAa,CAEJ,EAED,MAAM1D,EAAO,CACX,GAAIA,EAAM,QAAU,IAClB,OAGF,KAAM,CACJ,OAAAW,EACA,iBAAAoE,CACZ,EAAc,KAAK,WAET,GAAIpE,GAAUoE,GAAoB,KAAM,CACtC/E,EAAM,eAAc,EACpB,MAAMiF,EAAO,KAAK,MAAMF,CAAgB,EAClCkB,EAAW,KAAK,qBAAqBlB,CAAgB,EAE3D,GAAIE,GAAQ,MAAQgB,GAAYA,EAAS,aAAa,UAAU,EAC9D,OAGF,KAAK,sBAAsB,CACzB,KAAMpC,EACpB,CAAa,CACF,CACF,EAED,OAAO7D,EAAO,CACZA,EAAM,eAAc,EACpB,KAAK,MAAM,CACT,KAAM4D,GACN,GAAI,CAAC,KAAK,MAAM,QAAU,CACxB,aAAc,KACd,WAAY,EAC1B,CACA,CAAW,CACF,CAET,EACM,KAAK,sBAAwB,CAAE,GAAG,KAAK,gBAErC,IAAI5D,EAAO,CACTA,EAAM,eAAc,EACpB,KAAK,WAAW,CACd,KAAMmE,EAClB,CAAW,CACF,CAET,EACM,KAAK,qBAAuB,CAAE,GAAG,KAAK,gBAEpC,KAAKnE,EAAO,CACV,KAAM,CACJ,OAAAW,CACZ,EAAc,KAAK,WAET,GAAI,CAACA,EACH,OAGFX,EAAM,eAAc,EACpB,MAAMkC,EAAY,KAAK,eAEvB,GAAIA,GAAa,GAAK,CAACvB,EACrB,OAIF,MAAMuF,EAAsB1D,EAAwB,EAAG,EAAGN,EAAWQ,GAAS,KAAK,qBAAqBA,CAAK,EAAG,EAAK,EACrH,KAAK,oBAAoBwD,EAAqB,CAC5C,KAAMpC,EAClB,CAAW,CACF,EAED,IAAI9D,EAAO,CACT,KAAM,CACJ,OAAAW,CACZ,EAAc,KAAK,WAET,GAAI,CAACA,EACH,OAGFX,EAAM,eAAc,EACpB,MAAMkC,EAAY,KAAK,eAEvB,GAAIA,GAAa,GAAK,CAACvB,EACrB,OAIF,MAAMuF,EAAsB1D,EAAwB,GAAIN,EAAY,EAAGA,EAAWQ,GAAS,KAAK,qBAAqBA,CAAK,EAAG,EAAK,EAClI,KAAK,oBAAoBwD,EAAqB,CAC5C,KAAMnC,EAClB,CAAW,CACF,CAET,EAEM,KAAK,qBAAuB,SAAUoC,EAAQ,CAC5C,GAAI,CACF,QAAAC,EACA,QAAAC,EACA,UAAAC,EACA,QAAAC,EACA,OAAAC,EACA,GAAGX,CACJ,EAAGM,IAAW,OAAS,CAAA,EAAKA,EAE7B,KAAM,CACJ,OAAAxF,CACV,EAAYiE,EAAM,WAEJ6B,EAAuB,CAC3B,QAAS7G,EAAqBwG,EAASxB,EAAM,iBAAiB,EAC9D,UAAWhF,EAAqB0G,EAAW1B,EAAM,mBAAmB,EACpE,QAAShF,EAAqB2G,EAAS3B,EAAM,iBAAiB,EAC9D,OAAQhF,EAAqB4G,EAAQ5B,EAAM,gBAAgB,CACrE,EACc8B,EAAgBb,EAAK,SAAW,CAAA,EAAKY,EAC3C,MAAO,CACL,KAAM,SACN,KAAM,SACN,aAAc9F,EAAS,aAAe,YACtC,gBAAiB,GACjB,cAAe,GACf,GAAG+F,EACH,GAAGb,CACb,CACA,EAEM,KAAK,kBAAoB7F,GAAS,CAEhCA,EAAM,eAAc,CAC5B,EAEM,KAAK,oBAAsBA,GAAS,CAClC,MAAM2B,EAAME,GAAkB7B,CAAK,EAE/B,KAAK,sBAAsB2B,CAAG,GAChC,KAAK,sBAAsBA,CAAG,EAAE,KAAK,KAAM3B,CAAK,CAE1D,EAEM,KAAK,kBAAoBA,GAAS,CAChCA,EAAM,eAAc,EAKhB,KAAK,MAAM,YAAY,SAAS,gBAAkB,KAAK,MAAM,YAAY,SAAS,MACpFA,EAAM,OAAO,QAYb,KAAK,mBAAmB,IAAM,KAAK,WAAW,CAC5C,KAAMoE,EACP,CAAA,CAAC,CAEZ,EAEM,KAAK,iBAAmBpE,GAAS,CAC/B,MAAM2G,EAAa3G,EAAM,OAGzB,KAAK,mBAAmB,IAAM,CACxB,CAAC,KAAK,cAAgB,KAAK,MAAM,YAAY,SAAS,eAAiB,MAAQ,KAAK,MAAM,YAAY,SAAS,cAAc,KAAO,KAAK,UAAY,KAAK,MAAM,YAAY,SAAS,gBAAkB2G,GAEzM,KAAK,MAAM,CACT,KAAMtC,EACpB,CAAa,CAEb,CAAS,CACT,EAEM,KAAK,cAAgB5C,IACZ,CACL,QAAS,KAAK,QACd,GAAI,KAAK,QACT,GAAGA,CACb,GAGM,KAAK,cAAgB,SAAUmF,EAAQ,CACrC,GAAI,CACF,UAAAN,EACA,OAAAE,EACA,SAAAK,EACA,QAAAC,EACA,aAAAC,EACA,GAAGlB,CACJ,EAAGe,IAAW,OAAS,CAAA,EAAKA,EACzBI,EACAN,EAAgB,CAAA,EAIlBM,EAAc,WAGhB,KAAM,CACJ,WAAAC,EACA,OAAAtG,EACA,iBAAAoE,CACV,EAAYH,EAAM,WAEV,OAAKiB,EAAK,WACRa,EAAgB,CACd,CAACM,CAAW,EAAGpH,EAAqBiH,EAAUC,EAASlC,EAAM,iBAAiB,EAC9E,UAAWhF,EAAqB0G,EAAW1B,EAAM,kBAAkB,EACnE,OAAQhF,EAAqB4G,EAAQ5B,EAAM,eAAe,CACtE,GAGe,CACL,oBAAqB,OACrB,wBAAyBjE,GAAU,OAAOoE,GAAqB,UAAYA,GAAoB,EAAIH,EAAM,UAAUG,CAAgB,EAAI,KACvI,gBAAiBpE,EAASiE,EAAM,OAAS,KACzC,kBAAmBA,EAAM,QAGzB,aAAc,MACd,MAAOqC,EACP,GAAIrC,EAAM,QACV,GAAG8B,EACH,GAAGb,CACb,CACA,EAEM,KAAK,mBAAqB7F,GAAS,CACjC,MAAM2B,EAAME,GAAkB7B,CAAK,EAE/B2B,GAAO,KAAK,qBAAqBA,CAAG,GACtC,KAAK,qBAAqBA,CAAG,EAAE,KAAK,KAAM3B,CAAK,CAEzD,EAEM,KAAK,kBAAoBA,GAAS,CAChC,KAAK,iBAAiB,CACpB,KAAMkE,GACN,OAAQ,GACR,WAAYlE,EAAM,OAAO,MACzB,iBAAkB,KAAK,MAAM,uBACvC,CAAS,CACT,EAEM,KAAK,gBAAkB,IAAM,CAE3B,KAAK,mBAAmB,IAAM,CAC5B,MAAMkH,EAA0B,KAAK,MAAM,YAAY,UAAY,CAAC,CAAC,KAAK,MAAM,YAAY,SAAS,eAAiB,CAAC,CAAC,KAAK,MAAM,YAAY,SAAS,cAAc,SAAW,KAAK,MAAM,YAAY,SAAS,cAAc,QAAQ,QAAU,KAAK,WAAa,KAAK,UAAU,SAAS,KAAK,MAAM,YAAY,SAAS,aAAa,EAEpU,CAAC,KAAK,aAAe,CAACA,GACxB,KAAK,MAAM,CACT,KAAMjD,EACpB,CAAa,CAEb,CAAS,CACT,EAEM,KAAK,QAAUzF,GAAQ,CACrB,KAAK,UAAYA,CACzB,EAEM,KAAK,aAAe,SAAU2I,EAAQC,EAAQ,CAC5C,GAAI,CACF,OAAAxB,EAAS,MACT,IAAArF,EACA,GAAGkB,CACJ,EAAG0F,IAAW,OAAS,CAAA,EAAKA,EACzB,CACF,iBAAArB,EAAmB,EACpB,EAAGsB,IAAW,OAAS,CAAA,EAAKA,EAC7B,OAAAxC,EAAM,aAAa,OAAS,GAC5BA,EAAM,aAAa,OAASgB,EAC5BhB,EAAM,aAAa,iBAAmBkB,EAC/B,CACL,CAACF,CAAM,EAAGzF,GAAWI,EAAKqE,EAAM,OAAO,EACvC,KAAM,UACN,kBAAmBnD,GAASA,EAAM,YAAY,EAAI,KAAOmD,EAAM,QAC/D,GAAIA,EAAM,OACV,GAAGnD,CACb,CACA,EAEM,KAAK,aAAe,SAAU4F,EAAQ,CACpC,GAAI,CACF,YAAAC,EACA,YAAAC,EACA,QAAAnB,EACA,QAAAC,EACA,MAAA3D,EACA,KAAAuC,EAEA,OACA,GAAGY,CACJ,EAAGwB,IAAW,OAAS,CAAA,EAAKA,EAEzB3E,IAAU,QACZkC,EAAM,MAAM,KAAKK,CAAI,EAErBvC,EAAQkC,EAAM,MAAM,QAAQK,CAAI,GAEhCL,EAAM,MAAMlC,CAAK,EAAIuC,EAGvB,MAAMuC,EAAc,UACdC,EAAqBrB,EACrBK,EAAuB,CAI3B,YAAa7G,EAAqB0H,EAAa,IAAM,CAC/C5E,IAAUkC,EAAM,SAAQ,EAAG,mBAI/BA,EAAM,oBAAoBlC,EAAO,CAC/B,KAAMe,EACpB,CAAa,EAMDmB,EAAM,eAAiB,GAEvBA,EAAM,mBAAmB,IAAMA,EAAM,eAAiB,GAAO,GAAG,EAC5E,CAAW,EACD,YAAahF,EAAqB2H,EAAavH,GAAS,CAItDA,EAAM,eAAc,CAChC,CAAW,EACD,CAACwH,CAAW,EAAG5H,EAAqB6H,EAAoB,IAAM,CAC5D7C,EAAM,kBAAkBlC,EAAO,CAC7B,KAAMsB,EACpB,CAAa,CACb,CAAW,CACX,EAGc0C,EAAgBb,EAAK,SAAW,CACpC,YAAaY,EAAqB,WACnC,EAAGA,EACJ,MAAO,CACL,GAAI7B,EAAM,UAAUlC,CAAK,EACzB,KAAM,SACN,gBAAiBkC,EAAM,SAAU,EAAC,mBAAqBlC,EACvD,GAAGgE,EACH,GAAGb,CACb,CACA,EAEM,KAAK,WAAa,IAAM,CACtB,KAAK,MAAQ,EACrB,EAEM,KAAK,MAAQ,SAAUb,EAAiB3G,EAAI,CACtC2G,IAAoB,SACtBA,EAAkB,CAAA,GAGpBA,EAAkB3D,EAAU2D,CAAe,EAE3CJ,EAAM,iBAAiBjG,GAAQ,CAC7B,GAAI,CACF,aAAA+I,CACD,EAAG/I,EACJ,MAAO,CACL,OAAQiG,EAAM,MAAM,cACpB,iBAAkBA,EAAM,MAAM,wBAC9B,WAAYA,EAAM,MAAM,aAAa8C,CAAY,EACjD,GAAG1C,CACf,CACS,EAAE3G,CAAE,CACb,EAEM,KAAK,WAAa,SAAU2G,EAAiB3G,EAAI,CAC3C2G,IAAoB,SACtBA,EAAkB,CAAA,GAGpBA,EAAkB3D,EAAU2D,CAAe,EAE3CJ,EAAM,iBAAiBlE,GAAS,CAC9B,GAAI,CACF,OAAAC,CACD,EAAGD,EACJ,MAAO,CACL,OAAQ,CAACC,EACT,GAAIA,GAAU,CACZ,iBAAkBiE,EAAM,MAAM,uBAC5C,EACY,GAAGI,CACf,CACA,EAAW,IAAM,CACP,KAAM,CACJ,OAAArE,EACA,iBAAAoE,CACZ,EAAcH,EAAM,WAENjE,GACEiE,EAAM,aAAc,EAAG,GAAK,OAAOG,GAAqB,UAC1DH,EAAM,oBAAoBG,EAAkBC,CAAe,EAI/D5G,GAAOC,CAAE,GACnB,CAAS,CACT,EAEM,KAAK,SAAWA,GAAM,CACpB,KAAK,iBAAiB,CACpB,OAAQ,EACT,EAAEA,CAAE,CACb,EAEM,KAAK,UAAYA,GAAM,CACrB,KAAK,iBAAiB,CACpB,OAAQ,EACT,EAAEA,CAAE,CACb,EAEM,KAAK,aAAec,GAAS,IAAM,CACjC,MAAMmC,EAAQ,KAAK,WACb2D,EAAO,KAAK,MAAM3D,EAAM,gBAAgB,EACxCV,EAAc,KAAK,eACnBwC,EAAS,KAAK,MAAM,qBAAqB,CAC7C,aAAc,KAAK,MAAM,aACzB,oBAAqB,KAAK,oBAC1B,YAAAxC,EACA,gBAAiBqE,EACjB,GAAG3D,CACb,CAAS,EACD,KAAK,oBAAsBV,EAC3BuC,GAAUC,EAAQ,KAAK,MAAM,YAAY,QAAQ,CAClD,EAAE,GAAG,EAIN,KAAM,CACJ,wBAAAuE,EACA,wBAAyBC,EAAoBD,EAC7C,cAAAE,EACA,cAAeC,EAAUD,EACzB,kBAAmBE,EAAc,GACjC,oBAAqBC,EAAgB,IAC7C,EAAU,KAAK,MAEHC,EAAS,KAAK,SAAS,CAC3B,iBAAkBL,EAClB,OAAQE,EACR,WAAYC,EACZ,aAAcC,CACtB,CAAO,EAEGC,EAAO,cAAgB,MAAQ,KAAK,MAAM,oBAAsB,SAClEA,EAAO,WAAa,KAAK,MAAM,aAAaA,EAAO,YAAY,GAGjE,KAAK,MAAQA,CACd,CAKD,uBAAwB,CACtB,KAAK,WAAW,QAAQpD,GAAM,CAC5B,aAAaA,CAAE,CACvB,CAAO,EACD,KAAK,WAAa,EACnB,CAYD,SAASqD,EAAc,CACrB,OAAIA,IAAiB,SACnBA,EAAe,KAAK,OAGf1G,GAAS0G,EAAc,KAAK,KAAK,CACzC,CAED,cAAe,CAKb,IAAIhG,EAAY,KAAK,MAAM,OAE3B,OAAI,KAAK,WAAa,KACpBA,EAAY,KAAK,UACR,KAAK,MAAM,YAAc,SAClCA,EAAY,KAAK,MAAM,WAGlBA,CACR,CAED,qBAAqBQ,EAAO,CAC1B,OAAO,KAAK,MAAM,YAAY,SAAS,eAAe,KAAK,UAAUA,CAAK,CAAC,CAC5E,CAED,+BAAgC,CAE9B,CACE,MAAMlE,EAAO,KAAK,qBAAqB,KAAK,SAAQ,EAAG,gBAAgB,EACvE,KAAK,MAAM,eAAeA,EAAM,KAAK,SAAS,CAC/C,CACF,CAED,qBAAqBuH,EAAQf,EAAiB,CAC5C,MAAM9C,EAAY,KAAK,eACjB,CACJ,iBAAA6C,CACR,EAAU,KAAK,WAET,GAAI7C,EAAY,EAAG,CACjB,MAAM8D,EAAuBjE,GAAqBgE,EAAQhB,EAAkB7C,EAAWQ,GAAS,KAAK,qBAAqBA,CAAK,CAAC,EAChI,KAAK,oBAAoBsD,EAAsBhB,CAAe,CAC/D,CACF,CAED,oBAAqB,CACnB,KAAM,CACJ,iBAAAD,EACA,WAAAkC,EACA,aAAAS,EACA,OAAA/G,CACR,EAAU,KAAK,WACH,CACJ,aAAAwH,CACR,EAAU,KAAK,MACH,CACJ,GAAAtD,CACD,EAAG,KACE,CACJ,aAAAuD,EACA,qBAAAC,EACA,cAAAC,EACA,aAAAC,EACA,cAAAC,EACA,aAAAC,EACA,SAAAC,EACA,UAAAC,EACA,WAAAC,EACA,WAAAC,EACA,kBAAAC,EACA,sBAAAC,EACA,oBAAAC,EACA,eAAAC,EACA,WAAAC,EACA,MAAAC,EACA,aAAAC,EACA,eAAAC,EACA,iBAAkBC,CACnB,EAAG,KACJ,MAAO,CAEL,aAAAlB,EACA,qBAAAC,EACA,cAAAC,EACA,aAAAC,EACA,cAAAC,EACA,aAAAC,EAEA,MAAAU,EACA,SAAAT,EACA,UAAAC,EACA,WAAAC,EACA,WAAAC,EACA,kBAAAC,EACA,sBAAAC,EACA,oBAAAC,EACA,eAAAC,EACA,WAAAC,EACA,aAAAE,EACA,eAAAC,EACA,SAAAC,EAEA,aAAAnB,EAEA,GAAAtD,EAEA,iBAAAE,EACA,WAAAkC,EACA,OAAAtG,EACA,aAAA+G,CACR,CACK,CAGD,mBAAoB,CAQlB,CAME,MAAMH,EAAc,IAAM,CACxB,KAAK,YAAc,EAC7B,EAEcgC,EAAYvJ,GAAS,CACzB,KAAK,YAAc,GAKf,CAF2B2C,GAAsB3C,EAAM,OAAQ,CAAC,KAAK,UAAW,KAAK,SAAS,EAAG,KAAK,MAAM,WAAW,GAE5F,KAAK,SAAQ,EAAG,QAC7C,KAAK,MAAM,CACT,KAAMwD,EACpB,EAAe,IAAM,KAAK,MAAM,aAAa,KAAK,mBAAoB,CAAA,CAAC,CAEvE,EAQcgG,EAAe,IAAM,CACzB,KAAK,YAAc,EAC7B,EAEcC,EAAc,IAAM,CACxB,KAAK,YAAc,EAC7B,EAEcC,EAAa1J,GAAS,CAC1B,MAAM2J,EAAyBhH,GAAsB3C,EAAM,OAAQ,CAAC,KAAK,UAAW,KAAK,SAAS,EAAG,KAAK,MAAM,YAAa,EAAK,EAE9H,CAAC,KAAK,aAAe,CAAC2J,GAA0B,KAAK,SAAU,EAAC,QAClE,KAAK,MAAM,CACT,KAAMpF,EACpB,EAAe,IAAM,KAAK,MAAM,aAAa,KAAK,mBAAoB,CAAA,CAAC,CAEvE,EAEc,CACJ,YAAArF,CACV,EAAY,KAAK,MACTA,EAAY,iBAAiB,YAAaqI,CAAW,EACrDrI,EAAY,iBAAiB,UAAWqK,CAAS,EACjDrK,EAAY,iBAAiB,aAAcsK,CAAY,EACvDtK,EAAY,iBAAiB,YAAauK,CAAW,EACrDvK,EAAY,iBAAiB,WAAYwK,CAAU,EAEnD,KAAK,QAAU,IAAM,CACnB,KAAK,sBAAqB,EAC1B,KAAK,aAAa,SAClBxK,EAAY,oBAAoB,YAAaqI,CAAW,EACxDrI,EAAY,oBAAoB,UAAWqK,CAAS,EACpDrK,EAAY,oBAAoB,aAAcsK,CAAY,EAC1DtK,EAAY,oBAAoB,YAAauK,CAAW,EACxDvK,EAAY,oBAAoB,WAAYwK,CAAU,CAChE,CACO,CACF,CAED,aAAahI,EAAWkI,EAAW,CACjC,KAAM,CACJ,iBAAkBC,CAC1B,EAAU,KAAK,MAAM,mBAAqB,OAAY,KAAK,SAAQ,EAAK,KAAK,MACjE,CACJ,iBAAkBC,CACnB,EAAGF,EAAU,mBAAqB,OAAYlI,EAAYkI,EAG3D,OAFuBC,GAA2B,KAAK,SAAU,EAAC,QAAU,CAACnI,EAAU,QAC1DmI,IAA4BC,CAE1D,CAED,mBAAmBF,EAAWlI,EAAW,CAUnCE,GAAiB,KAAK,MAAO,cAAc,GAAK,KAAK,MAAM,oBAAoBgI,EAAU,aAAc,KAAK,MAAM,YAAY,GAChI,KAAK,iBAAiB,CACpB,KAAMtF,GACN,WAAY,KAAK,MAAM,aAAa,KAAK,MAAM,YAAY,CACrE,CAAS,EAGC,CAAC,KAAK,gBAAkB,KAAK,aAAa5C,EAAWkI,CAAS,GAChE,KAAK,8BAA6B,EAMlC,KAAK,aAAY,CAEpB,CAED,sBAAuB,CACrB,KAAK,QAAO,CACb,CAED,QAAS,CACP,MAAMG,EAAWjJ,GAAY,KAAK,MAAM,SAAUxC,CAAI,EAItD,KAAK,WAAU,EAKf,KAAK,aAAa,OAAS,GAC3B,KAAK,aAAa,OAAS,OAC3B,KAAK,aAAa,iBAAmB,OAErC,KAAK,aAAa,OAAS,GAC3B,KAAK,aAAa,OAAS,OAC3B,KAAK,aAAa,iBAAmB,OAErC,KAAK,cAAc,OAAS,GAE5B,KAAK,cAAc,OAAS,GAC5B,MAAM4C,EAAUJ,GAAYiJ,EAAS,KAAK,mBAAoB,CAAA,CAAC,EAE/D,GAAI,CAAC7I,EACH,OAAO,KAGT,GAAI,KAAK,aAAa,QAAU,KAAK,MAAM,iBAKzC,OAAOA,EACF,GAAID,GAAaC,CAAO,EAG7B,OAAoB8I,GAAAA,aAAa9I,EAAS,KAAK,aAAaC,GAAgBD,CAAO,CAAC,CAAC,CAcxF,CAEF,CAED,OAAAuD,EAAU,aAAe,CACvB,wBAAyB,KACzB,cAAe,GACf,qBAAsBhE,GACtB,aAAcvF,GACRA,GAAK,KACA,GAQF,OAAOA,CAAC,EAEjB,cAAeoD,EACf,mBAAoBA,EACpB,aAAcA,EACd,SAAUA,EACV,SAAUA,EACV,aAAcA,EACd,oBAAqB,CAAC2L,EAAUhF,IAASgF,IAAahF,EACtD,YAEA,OAAO,OAAW,IAAc,CAAA,EAAK,OACrC,aAAc,CAAC3D,EAAO6D,IAAeA,EACrC,iBAAkB,GAClB,eAAA5G,EACJ,EACEkG,EAAU,iBAAmBD,GACtBC,CACT,KAgDA,IAAIyF,GAAczF,GAsFlB,SAAS0F,GAAa1O,EAAGC,EAAG,CAC1B,OAAOA,EAAE,OACX,CASA,SAAS0O,GAAwBC,EAAqB,CACpD,KAAM,CACJ,aAAA3C,EACA,aAAc4C,CACf,EAAGD,EACJ,OAAO3C,EAAe,GAAG4C,EAAkB5C,CAAY,CAAC,sBAAwB,EAClF,CAMyBvI,GAAS,CAACoL,EAAgBC,IAAa,CAC9DrH,GAAUoH,IAAkBC,CAAQ,CACtC,EAAG,GAAG,EAmCN,SAASrC,GAAalD,EAAM,CAC1B,OAAOA,EAAO,OAAOA,CAAI,EAAI,EAC/B,CA4EA,MAAMwF,EAAiB,CACrB,aAAAtC,GACA,aAAAgC,GACA,wBAAAC,GACA,eAAA7L,GACA,mBAAoB,GACpB,YAEA,OAAO,OAAW,IAAc,CAAA,EAAK,MACvC,EAyXWmM,EAAU,MAAM,WACTA,EAAU,KACFA,EAAU,KACPA,EAAU,KACfA,EAAU,KACZA,EAAU,OACHA,EAAU,OACVA,EAAU,OAC3BA,EAAU,KACHA,EAAU,KACVA,EAAU,KACXA,EAAU,IACHA,EAAU,IACVA,EAAU,IAC3BA,EAAU,OACLA,EAAU,OACXA,EAAU,OACPA,EAAU,KACLA,EAAU,OACZA,EAAU,KACFA,EAAU,KACNA,EAAU,KACrBA,EAAU,KACTA,EAAU,KACbA,EAAU,MAAM,CACzB,iBAAkBA,EAAU,KAC5B,oBAAqBA,EAAU,KAC/B,SAAUA,EAAU,MAAM,CACtB,eAAgBA,EAAU,KAC1B,cAAeA,EAAU,IACzB,KAAMA,EAAU,GAC5B,CAAS,CACT,CAAK,EAUL,SAASC,GAAqBC,EAAI,CAC9B,IAAIjK,EAASiK,EAAG,OAAQhK,EAAcgK,EAAG,YAAa/J,EAAsB+J,EAAG,oBAC/E,OAAKjK,EAGAC,EAGDA,IAAgBC,EACT,GAAG,OAAOD,EAAa,SAAS,EAAE,OAAOA,IAAgB,EAAI,MAAQ,QAAS,8FAA8F,EAEhL,GALI,4BAHA,EASf,CACqBiK,GAASA,GAAS,CAAA,EAAIJ,CAAc,EAAG,CAAE,qBAAsBE,GAAsB,EAivBjGD,EAAU,MAAM,WACTA,EAAU,KACFA,EAAU,KACPA,EAAU,KACfA,EAAU,KACZA,EAAU,OACHA,EAAU,OACVA,EAAU,OAC3BA,EAAU,KACHA,EAAU,KACVA,EAAU,KACXA,EAAU,IACHA,EAAU,IACVA,EAAU,IACnBA,EAAU,OACHA,EAAU,OACVA,EAAU,OACzBA,EAAU,OACLA,EAAU,OACXA,EAAU,OACPA,EAAU,KACZA,EAAU,OACHA,EAAU,OACZA,EAAU,KACFA,EAAU,KACNA,EAAU,KACrBA,EAAU,KACTA,EAAU,KACNA,EAAU,KACjBA,EAAU,MAAM,CAC3B,iBAAkBA,EAAU,KAC5B,oBAAqBA,EAAU,KAC/B,SAAUA,EAAU,MAAM,CACxB,eAAgBA,EAAU,KAC1B,cAAeA,EAAU,IACzB,KAAMA,EAAU,GACtB,CAAK,CACL,CAAG,GA4CoB,CAAE,GAAGD,CAG5B,GA2qBA,SAASK,GAAsBT,EAAqB,CAClD,KAAM,CACJ,oBAAAU,EACA,aAAcT,CACf,EAAGD,EACJ,MAAO,GAAGC,EAAkBS,CAAmB,CAAC,oBAClD,CAGiBL,EAAU,MACHA,EAAU,MACVA,EAAU,MAClBA,EAAU,KACDA,EAAU,KACnBA,EAAU,KACXA,EAAU,OACHA,EAAU,OACVA,EAAU,OACTA,EAAU,KACRA,EAAU,KACdA,EAAU,OACNA,EAAU,OACpBA,EAAU,MAAM,CAC3B,iBAAkBA,EAAU,KAC5B,oBAAqBA,EAAU,KAC/B,SAAUA,EAAU,MAAM,CACxB,eAAgBA,EAAU,KAC1B,cAAeA,EAAU,IACzB,KAAMA,EAAU,GACtB,CAAK,CACL,CAAG,EAGaD,EAAe,aACfA,EAAe,aAChBA,EAAe,YC9xH9B,MAAAO,GAAAvJ,GAAA,CACE,KAAA,CAAA,GAAAoD,EAAA,iBAAAoG,EAAA,cAAAC,EAAA,WAAAC,CAAA,EAAA1J,EACA,CAAA2J,EAAAC,CAAA,EAAAC,GAAA,SAAA,CAAA,CAAA,EAEAC,EAAA,MAAAtE,GAAA,CACE,GAAA,CACE,MAAAuE,EAAA,MAAAC,GAAmDxE,EACjDkE,CACA,EAEFO,EAAAR,GAAA,MAAAA,EAAA,OAAAM,EAAA,SAAA,OAAAG,GAEM,CAAAT,EAAA,SAAAS,EAAA,OAAA,CAA2C,EAAAH,EAAA,SAGjDH,EAAAK,CAAA,CAAiB,OAAA3Q,EAAA,CAEjB,QAAA,IAAA,qBAAAA,CAAA,CAAmC,CACrC,EAGF6Q,EAAAC,GAAA,CACEZ,GACEA,EAAAY,CAAA,CACF,EAGF,OAAAC,EAAAC,GAAA,CAAA,SAAAD,EAEIrH,GAAC,CAAA,mBAAAwC,GAAA,CAEGsE,EAAAtE,CAAA,CAA6B,EAC/B,SAAAS,GAAAkE,EAAAlE,CAAA,EACqD,aAAAzC,GAAAA,GAAA,MAAAA,EAAA,KAAAA,EAAA,KAAA,GACL,SAAA,CAAA,CAE9C,cAAAuD,EACA,aAAAD,EACA,aAAAE,EACA,OAAA9H,EACA,WAAAsG,CACA,IAAA+E,GAAA,MAAA,CAAA,UAAA,kBAAA,SAAA,CAGEF,EAAA,QAAC,CAAA,GAAAtD,EAAA,CACmB,UAAA,eACL,GAAA3D,EACX,KAAA,SACM,KAAA,YACA,YAAA,mBACO,CAAA,EACd,MAAA,CAAA,aAAA,GAAA,CAC0B,CAAA,EAC7BiH,EACA,KAAC,CAAA,GAAAvD,EAAA,EACkB,UAAA5H,EAAA,gBAAA,GACqB,KAAA,OACjC,SAAAA,EAAAyK,EAAA,OAIEO,GAAA,CAAA1E,GAAA,GAAA0E,EAAA,SAAA,IAAAA,EAAA,QAAA,GAAA,SAGwC1E,CACnC,GAAA0E,EAAA,SAAA,SAAA1E,CAAA,CAE+B,EAAA,IAAA,CAAAhC,EAAAvC,IAAAoJ,EAGnC,KAAC,CAAA,GAAArD,EAAA,CAAA,IAAAxD,EAAA,QAAA,MAAAvC,EAAA,KAAAuC,EAAA,EAEoD,SAAA6G,EAEnDG,GAAC,CAAA,gBAAAhH,EACkB,YAAA,GACJ,aAAA,EACC,CAAA,CAChB,EAAA,iBAAAvC,CAAA,EAP2B,CAAA,EAAA,IAUjC,CAAA,CACN,EAAA,CACF,CAAA,CAAA,CAAA,CAKV","x_google_ignoreList":[0,1]}