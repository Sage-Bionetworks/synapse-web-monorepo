{"version":3,"file":"useSubscription-b20c5a8a.js","sources":["../../src/synapse-queries/subscription/useSubscription.ts"],"sourcesContent":["import {\n  Direction,\n  SortByType,\n  SubscriberPagedResults,\n  Subscription,\n  SubscriptionObjectType,\n  SubscriptionPagedResults,\n  SubscriptionQuery,\n  SubscriptionRequest,\n  Topic,\n} from '@sage-bionetworks/synapse-types'\nimport {\n  InfiniteData,\n  QueryKey,\n  useInfiniteQuery,\n  UseInfiniteQueryOptions,\n  useMutation,\n  UseMutationOptions,\n  useQuery,\n  useQueryClient,\n  UseQueryOptions,\n} from 'react-query'\nimport { SynapseClientError } from '../../utils/SynapseClientError'\nimport { useSynapseContext } from '../../utils'\nimport SynapseClient from '../../synapse-client'\nimport { useCallback } from 'react'\n\nexport function useGetSubscribers(\n  topic: Topic,\n  options?: UseQueryOptions<SubscriberPagedResults, SynapseClientError>,\n) {\n  const { accessToken, keyFactory } = useSynapseContext()\n  return useQuery<SubscriberPagedResults, SynapseClientError>(\n    keyFactory.getSubscribersQueryKey(topic.objectId, topic.objectType),\n    () => SynapseClient.getSubscribers(accessToken, topic),\n    options,\n  )\n}\n\nexport function useGetSubscription(\n  objectId: string,\n  objectType: SubscriptionObjectType,\n  options?: UseQueryOptions<Subscription, SynapseClientError>,\n) {\n  const { accessToken, keyFactory } = useSynapseContext()\n  const queryFn = async () => {\n    const subscriptionRequest: SubscriptionRequest = {\n      objectType: objectType,\n      idList: [objectId],\n      sortByType: SortByType.OBJECT_ID,\n      sortDirection: Direction.ASC,\n    }\n    const subscriptionList = await SynapseClient.postSubscriptionList(\n      accessToken,\n      subscriptionRequest,\n    )\n    return subscriptionList.results[0]\n  }\n  return useQuery<Subscription, SynapseClientError>(\n    keyFactory.getSubscriptionQueryKey(objectId, objectType),\n    queryFn,\n    options,\n  )\n}\n\nexport function useGetAllSubscriptions(\n  query: SubscriptionQuery,\n  options?: UseInfiniteQueryOptions<\n    SubscriptionPagedResults,\n    SynapseClientError,\n    Subscription\n  >,\n  queryKeyOverride?: QueryKey,\n) {\n  const { accessToken, keyFactory } = useSynapseContext()\n  const queryClient = useQueryClient()\n\n  return useInfiniteQuery<\n    SubscriptionPagedResults,\n    SynapseClientError,\n    Subscription\n  >(\n    queryKeyOverride ?? keyFactory.getAllSubscriptionsQueryKey(query),\n    async context => {\n      const offset = context.pageParam as number | undefined\n      return await SynapseClient.getAllSubscriptions(\n        accessToken,\n        10,\n        offset,\n        query,\n      )\n    },\n    {\n      ...options,\n      onSuccess: data => {\n        // Set the query data for each individual subscription that was retrieved\n        data.pages.forEach(subscription => {\n          queryClient.setQueryData(\n            keyFactory.getSubscriptionQueryKey(\n              subscription.objectId,\n              subscription.objectType,\n            ),\n            subscription,\n          )\n        })\n\n        if (options?.onSuccess) {\n          options.onSuccess(data)\n        }\n      },\n\n      select: data =>\n        ({\n          pages: data.pages.flatMap(page => page.results),\n          pageParams: data.pageParams,\n        } as InfiniteData<Subscription>),\n      getNextPageParam: (page, allPages) => {\n        const totalNumberOfFetchedResults = allPages.flatMap(\n          page => page.results,\n        ).length\n        if (page.totalNumberOfResults > totalNumberOfFetchedResults) {\n          return totalNumberOfFetchedResults\n        }\n        return undefined\n      },\n    },\n  )\n}\n\nexport function usePostSubscription(\n  options?: UseMutationOptions<Subscription, SynapseClientError, Topic>,\n) {\n  const queryClient = useQueryClient()\n  const { accessToken, keyFactory } = useSynapseContext()\n\n  return useMutation<Subscription, SynapseClientError, Topic>(\n    (topic: Topic) => SynapseClient.postSubscription(accessToken, topic),\n    {\n      ...options,\n      onSuccess: async (updatedSubscription, variables, ctx) => {\n        await Promise.all([\n          queryClient.invalidateQueries(\n            keyFactory.getAllSubscriptionsQueryKey(),\n          ),\n          queryClient.invalidateQueries(\n            keyFactory.getSubscriptionQueryKey(\n              variables.objectId,\n              variables.objectType,\n            ),\n          ),\n          queryClient.invalidateQueries(\n            keyFactory.getSubscribersQueryKey(\n              variables.objectId,\n              variables.objectType,\n            ),\n          ),\n        ])\n\n        if (options?.onSuccess) {\n          await options.onSuccess(updatedSubscription, variables, ctx)\n        }\n      },\n    },\n  )\n}\n\nexport function useDeleteSubscription(\n  options?: UseMutationOptions<void, SynapseClientError, Subscription>,\n) {\n  const queryClient = useQueryClient()\n  const { accessToken, keyFactory } = useSynapseContext()\n\n  return useMutation<void, SynapseClientError, Subscription>(\n    (subscription: Subscription) =>\n      SynapseClient.deleteSubscription(\n        accessToken,\n        subscription.subscriptionId,\n      ),\n    {\n      ...options,\n      onSuccess: async (updatedSubscription, variables, ctx) => {\n        await Promise.all([\n          queryClient.invalidateQueries(\n            keyFactory.getAllSubscriptionsQueryKey(),\n          ),\n          queryClient.invalidateQueries(\n            keyFactory.getSubscriptionQueryKey(\n              variables.objectId,\n              variables.objectType,\n            ),\n          ),\n          queryClient.invalidateQueries(\n            keyFactory.getSubscribersQueryKey(\n              variables.objectId,\n              variables.objectType,\n            ),\n          ),\n        ])\n\n        if (options?.onSuccess) {\n          await options.onSuccess(updatedSubscription, variables, ctx)\n        }\n      },\n    },\n  )\n}\n\nexport const useSubscription = (\n  objectId: string,\n  objectType: SubscriptionObjectType,\n) => {\n  const { data: subscription, isLoading: isLoadingGet } = useGetSubscription(\n    objectId,\n    objectType,\n  )\n  const { mutate: postSubscription, isLoading: isLoadingPost } =\n    usePostSubscription()\n  const { mutate: deleteSubscription, isLoading: isLoadingDelete } =\n    useDeleteSubscription()\n\n  const isLoading: boolean = isLoadingGet || isLoadingPost || isLoadingDelete\n  const toggleSubscribed = useCallback(() => {\n    if (subscription) {\n      deleteSubscription(subscription)\n    } else {\n      postSubscription({ objectId, objectType })\n    }\n  }, [deleteSubscription, objectId, objectType, postSubscription, subscription])\n\n  return {\n    isLoading,\n    subscription,\n    toggleSubscribed,\n    isSubscribed: Boolean(subscription),\n  }\n}\n"],"names":["useGetSubscribers","topic","options","accessToken","keyFactory","useSynapseContext","useQuery","SynapseClient","useGetSubscription","objectId","objectType","queryFn","subscriptionRequest","SortByType","Direction","useGetAllSubscriptions","query","queryKeyOverride","queryClient","useQueryClient","useInfiniteQuery","context","offset","data","subscription","page","allPages","totalNumberOfFetchedResults","usePostSubscription","useMutation","updatedSubscription","variables","ctx","useDeleteSubscription","useSubscription","isLoadingGet","postSubscription","isLoadingPost","deleteSubscription","isLoadingDelete","isLoading","toggleSubscribed","useCallback"],"mappings":"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"}