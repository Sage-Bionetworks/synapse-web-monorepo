var w=Object.defineProperty;var m=(i,n,e)=>n in i?w(i,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[n]=e;var o=(i,n,e)=>m(i,typeof n!="symbol"?n+"":n,e);import{j as r}from"./jsx-runtime-D_zvdyIk.js";import{r as u}from"./index-BULbjeCJ.js";import{I as f}from"./index-DVZp-uD1.js";import"./iframe-D8Kty_Cx.js";class l extends u.Component{constructor(e){super(e);o(this,"getObserverChildren",e=>{const{renderInView:t,renderOutOfView:d}=this.props;return(e.inView||this.state.hasBeenInView)&&t?t():!e.inView&&d?d():null});o(this,"onVisibilityChange",e=>{e?(this.setState({hasBeenInView:!0}),this.props.onEnterView&&this.props.onEnterView()):this.props.onLeaveView&&this.props.onLeaveView()});this.state={hasBeenInView:!1}}render(){const{rootMargin:e,tag:t}=this.props;return r.jsx(f,{as:t||"div",rootMargin:e,onChange:this.onVisibilityChange,children:this.getObserverChildren})}}try{l.displayName="VisibilityObserver",l.__docgenInfo={description:"VisibilityObserver uses the IntersectionObserver API to allow conditional child rendering and callbacks based\non viewport visibility. It will render the `renderOutOfView` prop until it is scrolled into view, then will\nalways render the `renderInView` prop instead. Callbacks will always be triggered on visibility changes.",displayName:"VisibilityObserver",props:{onEnterView:{defaultValue:null,description:"A callback which will be triggered when the component is scrolled into view.",name:"onEnterView",required:!1,type:{name:"() => void"}},onLeaveView:{defaultValue:null,description:"A callback which will be triggered when the component is scrolled out of view.",name:"onLeaveView",required:!1,type:{name:"() => void"}},renderInView:{defaultValue:null,description:`Render prop to return child content when the component is visible in the viewport. Once the component
has been in view it will always use this render prop, even when scrolled back out of view.`,name:"renderInView",required:!1,type:{name:"() => ReactNode"}},renderOutOfView:{defaultValue:null,description:"Render prop to return child content before the component becomes visible in the viewport.",name:"renderOutOfView",required:!1,type:{name:"() => ReactNode"}},tag:{defaultValue:{value:"'div'"},description:"Wrapper element tag name.",name:"tag",required:!1,type:{name:"string"}},rootMargin:{defaultValue:null,description:`A CSS margin string which pushes the intersection boundary further in or out of the viewport.
A positive value will expand the viewport threshold so your component is considered "in view" while it's
still offscreen, for example you could set thresholdOffset="200px" you want an image to start loading before
it scrolls into view. A negative value will move the boundary into the viewport, triggering "in view" after
it's already becoming visible.
"200px", "200px 0 50px 0", "-50px" are all valid values.`,name:"rootMargin",required:!1,type:{name:"string"}},className:{defaultValue:null,description:'One or more class names to be added to the root element of this component, i.e.\n`"class-one class-two"`.',name:"className",required:!1,type:{name:"string"}}}}}catch{}class a extends u.Component{constructor(){super(...arguments);o(this,"getChildren",()=>r.jsx(r.Fragment,{children:this.props.children}))}render(){return r.jsx(l,{renderInView:this.getChildren})}}try{a.displayName="RenderIfInView",a.__docgenInfo={description:"",displayName:"RenderIfInView",props:{}}}catch{}const O={title:"Components/RenderIfInView",component:a,render:i=>r.jsx(a,{children:r.jsx("div",{style:{backgroundColor:"#adedba",transition:"background-color 1s"},children:"RenderIfInView uses the IntersectionObserver API to allow conditional child rendering and callbacks based on viewport visibility. It will render children when it's scrolled into view."})})},s={};var c,p,h;s.parameters={...s.parameters,docs:{...(c=s.parameters)==null?void 0:c.docs,source:{originalSource:"{}",...(h=(p=s.parameters)==null?void 0:p.docs)==null?void 0:h.source}}};const x=["Demo"];export{s as Demo,x as __namedExportsOrder,O as default};
