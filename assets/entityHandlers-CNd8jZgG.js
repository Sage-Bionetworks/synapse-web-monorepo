import{l as d}from"./index-CzGBExuN.js";import{a5 as D,a6 as f,a7 as y,a8 as S,a9 as $,aa as g,ab as _,ac as v,ad as T}from"./SynapseClient-DlHMM3Ll.js";import{Y as m}from"./index-CcBaOCma.js";import{m as w,a as N}from"./index-BIbzHluK.js";import{a as L}from"./mockEntity-DNTLyavB.js";import{m as b}from"./mockSchema-CtiOyM9P.js";import"./OrientationBanner-D9iiRUAg.js";import{n as E}from"./EntityTypeUtils-B_e8UrIf.js";import"./getEndpoint-CjoHA800.js";import"./index-Dl6G-zuu.js";import"./jsx-runtime-Du8NFWEI.js";import{u as h}from"./uniqueId-CSw6ftlJ.js";const j=1111,C=2222,A=3333,M=4444,I={storageLocationId:D,uploadType:m.S3,banner:"",concreteType:"org.sagebionetworks.repo.model.file.S3UploadDestination"},k={...I,baseKey:"exampleS3BaseKey",stsEnabled:!0,concreteType:"org.sagebionetworks.repo.model.file.S3UploadDestination"},O={...k,storageLocationId:j,endpointUrl:"https://my-endpoint.fake",bucket:"myExternalS3Bucket",concreteType:"org.sagebionetworks.repo.model.file.ExternalS3UploadDestination"},U={...I,baseKey:"exampleGCPBaseKey",storageLocationId:C,uploadType:m.GOOGLECLOUDSTORAGE,bucket:"myExternalGCPBucket",concreteType:"org.sagebionetworks.repo.model.file.ExternalGoogleCloudUploadDestination"},R={...I,storageLocationId:A,uploadType:m.HTTPS,url:"https://myurl.fake",concreteType:"org.sagebionetworks.repo.model.file.ExternalUploadDestination"},G={...I,storageLocationId:M,uploadType:m.HTTPS,endpointUrl:"https://my-endpoint.fake",bucket:"myExternalObjectStoreBucket",keyPrefixUUID:"uuidKeyPrefix",concreteType:"org.sagebionetworks.repo.model.file.ExternalObjectStoreUploadDestination"},B=[k,O,U,R,G];function P(r){const n=r.map(E);return N.filter(a=>n.includes(E(a.id)))}function u(r){const n=P([r]);if(n.length!=0)return n[0]}function K(r,n){return d.rest.post(`${r}${T(":entityId")}`,async(a,o,s)=>{let t=404,e={reason:`Mock Service worker could not find a mock entity bundle with ID ${a.params.entityId}`};{const i=u(a.params.entityId);i!=null&&i.bundle&&(e=i.bundle,t=200)}return o(s.status(t),s.json(e))})}function Y(r,n){return d.rest.post(`${r}${T(":entityId",":versionNumber")}`,async(a,o,s)=>{const t=a.params.entityId,e=parseInt(a.params.versionNumber);let i=404,c={reason:`Mock Service worker could not find a mock entity bundle with ID ${t}`};{const l=u(t);if(l){const p=l.bundle;l.versions&&l.versions[e]?c={...p,entity:l.versions[e]}:c=p,i=200}}return o(s.status(i),s.json(c))})}const et=r=>[d.rest.post(`${r}${f}`,async(n,a,o)=>{let s=200;const t=await n.json();let e={reason:"..."};return t?t.name===L?(e.reason="Invalid project name",s=403):e={id:h("syn"),...t}:(s=400,e={reason:`Mock service worker received the following malformed body for PUT ${f} : ${JSON.stringify(t)}`}),a(o.status(s),o.json(e))}),d.rest.get(`${r}${y(":entityId")}`,async(n,a,o)=>{let s=404,t={reason:`Mock Service worker could not find a mock entity with ID ${n.params.entityId}`};const e=u(n.params.entityId);return e&&(t=e.entity,s=200),a(o.status(s),o.json(t))}),d.rest.get(`${r}${S(":entityId")}`,async(n,a,o)=>{let s=404,t={reason:`Mock Service worker could not find mock entity versions for ID ${n.params.entityId}`};const e=u(n.params.entityId);return e&&e.versionInfo&&(t={results:e.versionInfo},s=200),a(o.status(s),o.json(t))}),d.rest.get(`${r}${$(":entityId",":versionNumber")}`,async(n,a,o)=>{let s=404;const t=n.params.entityId,e=n.params.versionNumber.toString(),i=parseInt(e);let c={reason:`Mock Service worker could not find a mock versioned entity with ID ${t}.${e}`};const l=u(n.params.entityId);return l&&l.versions&&l.versions[i]&&(c=l.versions[i],s=200),a(o.status(s),o.json(c))}),K(r),Y(r),d.rest.get(`${r}${g(":entityId")}`,async(n,a,o)=>a(o.status(200),o.json(b))),d.rest.get(`${r}${_(":entityId")}`,async(n,a,o)=>{let s=404,t={reason:`Mock Service worker could not find a mock entity bundle with ID ${n.params.entityId}`};const e=u(n.params.entityId);return e!=null&&e.json&&(t=e.json,s=200),a(o.status(s),o.json(t))}),d.rest.post(`${r}${v}`,async(n,a,o)=>{let s=404,t={reason:`Mock Service worker could not find a mock entity bundle with ID ${n.params.entityId}`};const i=n.body.references.map(c=>{var p;const l=(p=u(c.targetId))==null?void 0:p.entityHeader;if(l)return{...l,id:c.targetId}}).filter(c=>!!c);return i&&(t={results:i},s=200),a(o.status(s),o.json(t))}),d.rest.get(`${r}${y(":entityId")}/path`,async(n,a,o)=>{let s=404,t={reason:`Mock Service worker could not find a mock entity path using ID ${n.params.entityId}`};const e=u(n.params.entityId);return e&&e.path&&(t=e.path,s=200),a(o.status(s),o.json(t))}),d.rest.get(`${r}/file/v1/entity/:id/uploadDestination`,async(n,a,o)=>{const s={banner:"",storageLocationId:1,uploadType:m.S3,concreteType:"org.sagebionetworks.repo.model.file.S3UploadDestination"};return a(o.status(200),o.json(s))}),d.rest.get(`${r}/file/v1/entity/:id/uploadDestination/:storageLocationId`,async(n,a,o)=>{let s=404,t={reason:`Mock Service worker could not find an uploadDestination using storageLocationId ${n.params.storageLocationId}`};const e=B.find(i=>Number(n.params.storageLocationId)===i.storageLocationId);return e&&(t=e,s=200),a(o.status(s),o.json(t))}),d.rest.get(`${r}/repo/v1/projects`,async(n,a,o)=>{const s={results:w.map(t=>({name:t.name,id:t.id,lastActivity:"2024-01-04T21:11:59.000Z",modifiedBy:parseInt(t.entity.modifiedBy),modifiedOn:t.entity.modifiedOn}))};return a(o.status(200),o.json(s))}),d.rest.post(`${r}${y(":entityId")}/acl`,async(n,a,o)=>{var i;const s=u(n.params.entityId);let t,e;return s?(i=s.bundle)!=null&&i.accessControlList?(t=403,e={reason:"Resource already has an ACL."}):(e=await n.json(),t=201):(t=404,e={reason:`Mock Service worker could not find a mock entity bundle with ID ${n.params.entityId}`}),a(o.status(t),o.json(e))}),d.rest.put(`${r}${y(":entityId")}/acl`,async(n,a,o)=>{var i;const s=u(n.params.entityId);let t,e;return s?(i=s==null?void 0:s.bundle)!=null&&i.accessControlList?(e=await n.json(),t=200):(e={reason:"Cannot update ACL for a resource which inherits its permissions."},t=403):(t=404,e={reason:`Mock Service worker could not find a mock entity bundle with ID ${n.params.entityId}`}),a(o.status(t),o.json(e))}),d.rest.delete(`${r}${y(":entityId")}/acl`,async(n,a,o)=>{var i;const s=u(n.params.entityId);let t,e;return s?(i=s==null?void 0:s.bundle)!=null&&i.accessControlList?(e="",t=200):(e={reason:"Cannot delete ACL for a resource which inherits its permissions."},t=403):(t=404,e={reason:`Mock Service worker could not find a mock entity bundle with ID ${n.params.entityId}`}),a(o.status(t),o.json(e))})];export{et as g};
